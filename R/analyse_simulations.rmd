---
title: 'Pushed expansions and sources of variation- individual-based model, data analysis'
author: "Maxime Dahirel & Chlo√© Guicharnaud"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(nlrx)
library(arm)
library(matrixStats)
library(tidyverse)
library(mgcv)
library(gratia)
library(cowplot)

library(arm)
library(ggdist)

library(here)
```

discussion thread to follow:
sources of evo available as constraints
compatibility between "yes, evo favours mostly DID over the range" BUT "still DDD+ over all, so still open to pushiness, especially if dmax increase", despite apparent paradox
general result still loss of pushiness in many cases, but only if genet div in matching traits (vs enhancing traits)
dispersal costs and heritability influence the dynamics
the DDD+ to DDD- pattern seen in a few studies is not recovered here (well it is, but not in a systematic way)
what's missing? obvious answer: evolution of life history, trade-offs...

# Introduction

```{r}
data <- read_csv(here("NetLogo_output","model-output.csv"))
```

<!--the classical result that costs = more DDD was in contexts where dmax and midpoint did not evolve-->
<!-- hyper important to understand eco-evo dynamics: check that N=0 cells within pops are not deleted-->

<!--key thing to do, check that the effect of absolute slope on speed/diversity is the same independently of source of variation (dmax only, matching only, both) or else difficult to compare their evol dynamics-->

# checking evolutionary and velocity convergence

```{r}
data %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  select(ticks,heritability,is.VP_dmax,is.VP_DDD,replicateID,present_front,dispersal_mortality) %>% 
  distinct() %>% 
  group_by(replicateID) %>% 
  mutate(speed=present_front/ticks) %>% 
  mutate(speed_final=subset(speed,ticks==120) %>% mean()) %>% 
  mutate(relative_speed=speed-speed_final) %>%
  ungroup() %>% 
  ggplot()+
  geom_line(aes(ticks,relative_speed,group=replicateID),col="lightgrey")+
  stat_lineribbon(aes(ticks,relative_speed),.width=c(0.001,0.95),point_interval = median_qi,
                  alpha=0.5)+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+
  geom_hline(yintercept = c(-0.025,0,0.025),lty=2)+
  scale_y_continuous("deviation from final velocity (in patches per generation)")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")
```
(use the facetted version in suppl, and maybe the general in main text)

takeaway: convergence in speed (which depends on both the stochasticity of the invasion smoothing itself out and the evolutionary process finishing) is fast, and speeds at g100 or g120 can reasonably be used as measures of long-run speed

another way to check it would be to see how speed changes from one measure to the next:

```{r}
data %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  select(ticks,heritability,is.VP_dmax,is.VP_DDD,replicateID,present_front,dispersal_mortality) %>% 
  distinct() %>% 
  group_by(replicateID) %>% 
  mutate(speed=present_front/ticks) %>% 
  arrange(ticks) %>% 
  mutate(deviation=speed-lag(speed)) %>% 
  ungroup() %>% 
  filter(ticks>1) %>% 
  ggplot()+
  geom_line(aes(ticks,deviation,group=replicateID),col="lightgrey")+
  stat_lineribbon(aes(ticks,deviation),.width=c(0.001,0.95),point_interval = median_qi,
                  alpha=0.5)+
  #facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
  #             cols=vars(heritability,is.VP_DDD))+
  geom_hline(yintercept = c(-0.025,0,0.025),lty=2)+
  scale_y_continuous("deviation in speed from previous measure (in patches per generation)")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")
```

let's do the same to look at evolutionary stability at the edge


```{r}
data %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  select(pxcor,ticks,heritability,is.VP_dmax,is.VP_DDD,replicateID,present_front,dispersal_mortality,
         var_dmax,var_midpoint,var_slope,
         var_genotype_logit_dmax,var_genotype_midpoint,var_genotype_slope,
         var_noise_logit_dmax,var_noise_midpoint,var_noise_slope) %>%
  filter(pxcor==present_front-5) %>%  
  group_by(replicateID) %>% 
  mutate(v_final=subset(var_genotype_midpoint,ticks==120) %>% mean()) %>% 
  mutate(relative_v=(var_genotype_midpoint-v_final)/0.5^2) %>%  ##initial variances: logitdmax 1.5^2, slope 6^2, midpoint 0.5^2
  ungroup() %>% 
  ggplot()+
  geom_line(aes(ticks,relative_v,group=replicateID),col="lightgrey")+
  stat_lineribbon(aes(ticks,relative_v),.width=c(0.001,0.95),point_interval = median_qi,
                  alpha=0.5)+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+
  geom_hline(yintercept = c(-0.025,0,0.025),lty=2)+
  scale_y_continuous("")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")
```

(we can NOT use "check if vA falls to zero" as a check for evolutionary stability, because in case of branching within a replicate, dynamics can be stable but vA very high, even higher than at t0 if "core" of the genotypic distri has been carved out)

lots of things to do to strengthen this, but we can carry on assuming convergence at g100 for the enxt steps

# checking pushiness



if convergence at g100, then we can make the following assumptions

-speed over g100-120 is predicted by d0 at g100. The shape of the curve is likely nonlinear, we'll avoid having to seek a correct form by using GAM

-deviations from the d0 prediction are expected, and explained by DDD, DDD+ = faster than expected based on d0, beased on pushiness

-mortality plays a role

```{r}
trait_data100<-data %>% 
  filter(ticks==100 & pxcor == present_front-5 ) %>%  # higher N so less noise than front - 1, so estimates of mean more accurate
  select(replicateID,
         mean_d0,mean_slopeA_0_avg,mean_slopeA_0_K,mean_slopeA_1_K,mean_slopeA_1_avg,
         mean_uncond0_K,mean_uncond1_K,front100=present_front)
##why is it less than 5400?? investigate

dynamic_data120<-data %>% 
    filter(ticks==120) %>% 
    mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  group_by(replicateID) %>% 
  mutate(front_0=max(pxcor*(N_allele0_post>0)),
         front_1=max(pxcor*(N_allele1_post>0))) %>% 
  mutate(front_lag=min(c(front_0,front_1)),
         front=max(c(front_0,front_1))) %>% 
  ungroup() %>% 
  select(front_lag,front,dispersal_mortality,replicateID,heritability, is.VP_dmax,is.VP_DDD,
         VP_slope,VP_midpoint,VP_logit_dmax, #keep for later
         slope_start,midpoint_start) %>% 
  mutate(mortality=factor(dispersal_mortality)) %>% 
  mutate(is.evo=as.numeric(heritability>0)) %>% 
  mutate(vartype=factor(paste("vP",is.VP_DDD>0 |is.VP_dmax>0,
                              "h",heritability))) %>% 
  distinct()
  
tab<-left_join(dynamic_data120,trait_data100)
  
mod=glm(cbind((front-front100),20-(front-front100))~(scale(mean_d0)+scale(mean_slopeA_0_avg))*mortality,family=binomial,data=tab)
## very basic: ignore possible effects of sources of variances

mod_div=glm(cbind(front_lag,front-front_lag)~(scale(mean_d0)+scale(mean_slopeA_0_K))*mortality,family=binomial,data=tab)
## justification: se e.g. roques 2012 for the idea that in (more) pushed expansions, speed of one fraction = to speed of whole expansion, + distance to fixation = integrator of time to fixation

#gam version?
mod=gam(cbind((front-front100),20-(front-front100))~
          s(mean_d0, by = mortality,k=10,bs="cr")+
          s(mean_slopeA_0_avg,by=mortality,k=10,bs="cr")+
          s(mean_uncond0_K,by=mortality,k=10,bs="cr")+
          mortality,
        family=binomial,data=tab,method="REML")

gam.check(mod) #
draw(mod)
appraise(mod)

mod_div=gam(cbind(front_lag,front-front_lag)~
          s(mean_d0, by = mortality,k=10,bs="cr")+
          s(mean_slopeA_0_avg,by=mortality,k=10,bs="cr")+
          s(mean_uncond0_K,by=mortality,k=10,bs="cr")+
          mortality,
        family=binomial,data=tab,method="REML")

gam.check(mod_div) #
draw(mod_div)
appraise(mod_div)

```

# analyse evolution

our main tool: the plot(y=trait after evol, x=trait at t0), deviation from nthe line y=x indicate evolution

```{r}
tab2 <- tab %>%  
  mutate(rnorm_slope_start=map2(.x=slope_start,.y=sqrt(VP_slope),.f=~rnorm(1000,.x,.y))) %>% 
  mutate(rnorm_midpoint_start=map2(.x=midpoint_start,.y=sqrt(VP_midpoint),.f=~rnorm(1000,.x,.y))) %>% 
  mutate(rnorm_dmax_start=map2(.x=0,.y=sqrt(VP_logit_dmax),.f=~rnorm(1000,.x,.y) %>% invlogit())) %>% 
  mutate(mean_dmax_start=map(.x=rnorm_dmax_start,.f=~.x %>% mean())) %>% 
  mutate(rnorm_function_start0=map2(.x=rnorm_slope_start,.y=rnorm_midpoint_start,
                                    .f=function(.x,.y){
                                      1/(1+exp(-.x*(0-.y)))
                                    })) %>% 
  mutate(rnorm_function_start0=map2(.x=rnorm_dmax_start,.y=rnorm_function_start0,
                                    .f=function(.x,.y){
                                      .x*.y
                                    }))%>% 
  mutate(rnorm_function_startK=map2(.x=rnorm_slope_start,.y=rnorm_midpoint_start,
                                    .f=function(.x,.y){
                                      1/(1+exp(-.x*(1-.y)))
                                    })) %>% 
  mutate(rnorm_function_startK=map2(.x=rnorm_dmax_start,.y=rnorm_function_startK,
                                    .f=function(.x,.y){
                                      .x*.y
                                    })) %>% 
  mutate(start_slopeA_0_K=map2(.x=rnorm_function_startK,.y=rnorm_function_start0,
                             .f=function(.x,.y){
                               mean((.x-.y)) ##arrange to keep K and code it correctly
                             })) %>% 
    mutate(start_slopeA_0_K_lower=map2(.x=rnorm_function_startK,.y=rnorm_function_start0,
                             .f=function(.x,.y){
                               quantile((.x-.y),0.025) ##arrange to keep K and code it correctly
                             })) %>% 
    mutate(start_slopeA_0_K_upper=map2(.x=rnorm_function_startK,.y=rnorm_function_start0,
                             .f=function(.x,.y){
                               quantile((.x-.y),0.975) ##arrange to keep K and code it correctly
                             })) %>% 
  mutate(start_avgdisp_std=map2(.x=rnorm_slope_start,.y=rnorm_midpoint_start,
                             .f=function(.x,.y){
                               N<-matrix(seq(0,1,0.1),ncol=11,nrow=1000,byrow=TRUE)
                               a<-1/(1+exp(-.x*(N-.y)))}
                             ))  %>% 
  mutate(start_avgdisp=map2(.x=rnorm_dmax_start,.y=start_avgdisp_std,
                             .f=function(.x,.y){
                               .x*.y}
                             ))  %>% 
  mutate(start_slopeA_0_avg=map2(.x=start_avgdisp,.y=rnorm_function_start0,
                             .f=function(.x,.y){
                               mean((.x-.y)) ##arrange to keep K and code it correctly
                             })) %>% 
  mutate(start_uncond0_K=map(.x=start_avgdisp_std,
                              .f=function(.x){
                                return(mean(rowMeans(.x)/rowMaxs(.x)))
                              })) %>% 
    mutate(start_uncond0_K_lower=map(.x=start_avgdisp_std,
                              .f=function(.x){
                                return(quantile(rowMeans(.x)/rowMaxs(.x),0.025))
                              })) %>% 
    mutate(start_uncond0_K_upper=map(.x=start_avgdisp_std,
                              .f=function(.x){
                                return(quantile(rowMeans(.x)/rowMaxs(.x),0.975))
                              })) %>% 
  unnest(c(start_slopeA_0_K,start_uncond0_K,start_slopeA_0_avg,mean_dmax_start,
           start_slopeA_0_K_upper,start_slopeA_0_K_lower,start_uncond0_K_upper,start_uncond0_K_lower))


ggplot(tab2)+
    geom_abline(intercept = 0,slope=1,lty=2)+
    geom_hline(yintercept = 0, lty=2)+
    geom_point(aes(start_slopeA_0_K,mean_slopeA_0_K))+
    geom_smooth(aes(start_slopeA_0_K,mean_slopeA_0_K),method="lm")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_upper),col="red")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_lower),col="red")+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+ 
    scale_x_continuous("original mean absolute slope",limits = c(-1,1))+
    scale_y_continuous("final mean absolute slope",limits = c(-1,1))

  ggplot(tab2)+
  geom_abline(intercept = 0,slope=1,lty=2)+
  geom_point(aes(start_uncond0_K,mean_uncond0_K))+
  geom_smooth(aes(start_uncond0_K,mean_uncond0_K),method="lm")+
    geom_line(aes(start_uncond0_K,start_uncond0_K_upper),col="red")+
  geom_line(aes(start_uncond0_K,start_uncond0_K_lower),col="red")+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
                       cols=vars(heritability,is.VP_DDD))+ 
  scale_x_continuous("original mean unconditionality index",limits = c(0,1.1))+
  scale_y_continuous("final mean unconditionality index",limits = c(0,1.1))
  
#using the last patch populated 
#  ggplot(test2)+
#  geom_hline(yintercept = 0.5,lty=2)+
#  geom_point(aes(start_slopeA_0_K,N_predispersal))+
#  geom_smooth(aes(start_slopeA_0_K,N_predispersal),method="glm",method.args = list(family = "poisson"))+
#  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
#                       cols=vars(heritability,is.VP_DDD))
#  
#  
#  ## you can use the patterns in the no-evol panel to show that even in absence of evol, DDD+ leads to higher mean #pop at frot predisp
#  ## whch is the pattern that could favour the maintenance of DDD+ when evol
```


```{r}

tab3<-tab2 %>% 
  mutate(panel=paste("mort",dispersal_mortality,
                     "vp_dmax",is.VP_dmax,
                     "vp_ddd",is.VP_DDD,
                     "h2",heritability)) %>% 
  select(panel,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,
         mean_slopeA_0_avg,start_slopeA_0_avg,
         mean_uncond0_K,start_uncond0_K) %>% 
  group_by(panel,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability) %>% 
  nest() %>% 
  mutate(lm_ddd=map(.x=data,.f=~lm(mean_slopeA_0_avg~start_slopeA_0_avg,data=.x))) %>% 
  mutate(sigma_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$sigma}),
         slope_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[2,"Estimate"]}),
         slope_ddd_se=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[2,"Std. Error"]}),
         int_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_ddd_se=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>%   
  mutate(lm_uncond=map(.x=data,.f=~lm(mean_uncond0_K~start_uncond0_K,data=.x))) %>% 
  mutate(sigma_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$sigma}),
         slope_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[2,"Estimate"]}),
         slope_uncond_se=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[2,"Std. Error"]}),
         int_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_uncond_se=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>% 
  unnest(c(sigma_ddd,slope_ddd,slope_ddd_se,int_ddd,int_ddd_se,
           sigma_uncond,slope_uncond,slope_uncond_se,int_uncond,int_uncond_se)) %>% 
  mutate(VP_source=case_when(is.VP_dmax==0 & is.VP_DDD==0~"none",
                             is.VP_dmax==1 & is.VP_DDD==0~"dmax only",
                             is.VP_dmax==0 & is.VP_DDD==1~"DDD only",
                             is.VP_dmax==1 & is.VP_DDD==1~"both")) %>% 
  ungroup()
  
#### plot for DDD
ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=slope_ddd,
                         ymin=slope_ddd-2*slope_ddd_se,ymax=slope_ddd+2*slope_ddd_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=slope_ddd,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=1,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(0,2.5))

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_ddd,
                         ymin=int_ddd-2*int_ddd_se,ymax=int_ddd+2*int_ddd_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_ddd,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(-0.25,0.25))

ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_ddd,col=VP_source),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_ddd,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)

### same plots for uncondition

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=slope_uncond,
                         ymin=slope_uncond-2*slope_uncond_se,ymax=slope_uncond+2*slope_uncond_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=slope_uncond,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=1,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(0,2.5))

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_uncond,
                         ymin=int_uncond-2*int_uncond_se,ymax=int_uncond+2*int_uncond_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_uncond,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(0,1))

ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_uncond,col=VP_source),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_uncond,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)
```

the more a trait is heritable the mor eunconditional the dispfunc becomes, and the stronger the slope becomes

needs to add plots for d0 and dmax to understand the dynamics


alt way of representing the info: deviation:

```{r}
ggplot(tab2)+
    geom_hline(yintercept = 0, lty=2)+
    geom_point(aes(start_slopeA_0_K,mean_slopeA_0_K-start_slopeA_0_K))+
    geom_smooth(aes(start_slopeA_0_K,mean_slopeA_0_K-start_slopeA_0_K),method="lm")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_upper-start_slopeA_0_K),col="red")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_lower-start_slopeA_0_K),col="red")+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+ 
    scale_x_continuous("original mean absolute slope",limits = c(-1,1))+
    scale_y_continuous("final deviation from original absolute slope",limits = c(-1,1))

  ggplot(tab2)+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(aes(start_uncond0_K,mean_uncond0_K-start_uncond0_K))+
  geom_smooth(aes(start_uncond0_K,mean_uncond0_K-start_uncond0_K),method="lm")+
    geom_line(aes(start_uncond0_K,start_uncond0_K_upper-start_uncond0_K),col="red")+
  geom_line(aes(start_uncond0_K,start_uncond0_K_lower-start_uncond0_K),col="red")+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
                       cols=vars(heritability,is.VP_DDD))+ 
  scale_x_continuous("original mean unconditionality index",limits = c(0,1.1))+
  scale_y_continuous("final deviation from original mean unconditionality index",limits = c(-1.1,1.1))
  

```


## notes ?
Ok it looks like we find the costs+ = ddd++ pattern only when dmax is not allowed to evolve (makes sense, wasn't allowed to in the models that showed this, iirc). But with dmax allowed to evolved, things are more messy


prediction from birzu: pulled waves favour evolution of strats with higher dispersal rate at the edge
can't look at the dispersal function, since N at the edge varies bw types, need to look at actual dispersal events



mmm... mayyyybe? but very dependent on what pxcor we whoose (front-1, front -2...), because N varies quickly. potentially interesting to look at d=f(distance from front)



