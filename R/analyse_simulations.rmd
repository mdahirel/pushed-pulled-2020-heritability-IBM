---
title: 'Pushed expansions and sources of variation- individual-based model, data analysis'
author: "Maxime Dahirel & Chlo√© Guicharnaud"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(arm)
library(matrixStats)
library(tidyverse)
library(cowplot)
library(patchwork)
library(tidybayes)


library(cmdstanr)
library(brms)
options(mc.cores = 4)

library(tidyverse)

library(here)
```

discussion thread to follow:
sources of evo available as constraints
compatibility between "yes, evo favours mostly DID over the range" BUT "still DDD+ over all, so still open to pushiness, especially if dmax increase", despite apparent paradox
general result still loss of pushiness in many cases, but only if genet div in matching traits (vs enhancing traits)
dispersal costs and heritability influence the dynamics
the DDD+ to DDD- pattern seen in a few studies is not recovered here (well it is, but not in a systematic way)
what's missing? obvious answer: evolution of life history, trade-offs...

# Introduction

```{r}
raw_data <- read_csv(here("NetLogo_output","model-output.csv"))
```

We rewrite variance variables to be in 0/1 mode to not be distracted

```{r}
data<- raw_data  %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  filter(ticks!=10)
```


# making sub data tables

a table with summary variables at the edge (we define edge as patch <5 patchs from tip, see suppl for justification)
```{r}
tab_edge<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor > front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,front)) %>% 
  mutate(where="edge")
```

we do the same for core patches

```{r}
tab_core<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor < 5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,front)) %>%
  mutate(where="core")
```

we also extract separately variables at t0
```{r}
tab_start<-data %>% select(
  start_dmax,
  start_midpoint,
  start_slope,
  start_d0,
  start_avgslope=start_slopeA_0_avg,
  start_Kslope=start_slopeA_0_K,
  start_uncond=start_uncond_0_K,
  replicateID
) %>% 
  distinct()

```

finally we run another extraction to get information on genetic diversity decay, time to fixation
(earliest observation of front (defined as above) only containing one of the two neutral alleles
)
```{r}
tab_genet <- data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor > front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    N_allele0=sum(N_allele0_post),
    N_allele1=sum(N_allele1_post)
  ) %>% 
  ungroup() %>% 
  mutate(edge_fix= N_allele0==0 | N_allele1==0) %>% 
  group_by(replicateID) %>% 
  mutate(time_to_fix=case_when(subset(edge_fix,ticks==20)==1 ~ 20,
                               subset(edge_fix,ticks==40)==1 ~ 40,
                               subset(edge_fix,ticks==60)==1 ~ 60,
                               subset(edge_fix,ticks==80)==1 ~ 80,
                               subset(edge_fix,ticks==100)==1 ~ 100,
                               subset(edge_fix,ticks==120)==1 ~ 120,
                               T~121)##not fixed yet at end of experiment
         ) %>% 
  ungroup() %>% 
  group_by(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(time_to_fix=unique(time_to_fix)) %>% 
  ungroup()
```

now we can mix and combine these datasets for analyses

# analysis of speed and genetic dynamics


```{r}
tab <-tab_edge %>% 
  left_join(tab_start) %>% 
  left_join(tab_genet) %>% 
  mutate(mortality=factor(dispersal_mortality)) %>% 
  mutate(advance=front_120-front_100) %>% 
  mutate(scale_d0_100=scale(mean_d0_100)[,1],
         scale_d0_start=scale(start_d0)[,1],
         s_avgslope_100=mean_avgslope_100/sd(mean_avgslope_100),
         s_avgslope_start=start_avgslope/sd(start_avgslope),
         s_Kslope_100=mean_Kslope_100/sd(mean_Kslope_100),
         s_Kslope_start=start_Kslope/sd(start_Kslope))
```

for both velocity and genetics, we compare 4 models:

- one with and one without the density-dependency variable (is knowledge of DDD needed to predict?)
- both taken at g100 and at the start of the experiment (is knowledge of evolution needed?)

## velocity evidence

patches are discrete entities, and speed is capped at one patch/generation. So let's start with binomial models:

```{r}
prior_velocity<-c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        )
```


```{r}
if(file.exists(here("R_output","models_velocity_binom.Rdata"))){
  # this if-else statement is avoid re-fitting a model if there is already one existing in R_output
  # to override, re-run and re-save manually the model by selecting only relevant code lines, instead of running the entire chunk, or delete the saved object
  load(here("R_output","models_velocity_binom.Rdata"))
  }else
    {
      
mod_100=brm(bf(advance|trials(20)~
          (scale_d0_100+s_avgslope_100)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_100_K=brm(bf(advance|trials(20)~
          (scale_d0_100+s_Kslope_100)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_100_noDDD=brm(bf(advance|trials(20)~
          (scale_d0_100)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_00=brm(bf(advance|trials(20)~
          (scale_d0_start+s_avgslope_start)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_00_K=brm(bf(advance|trials(20)~
          (scale_d0_start+s_Kslope_start)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_00_noDDD=brm(bf(advance|trials(20)~
          (scale_d0_start)*mortality),
        family=binomial,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

save(list=c("mod_100","mod_100_K","mod_100_noDDD",
            "mod_00","mod_00_K","mod_00_noDDD"), 
     file=here("R_output","models_velocity_binom.Rdata"))
    }
```

```{r}
if(file.exists(here("R_output","loo_velocity_binom.Rdata"))){
  load(here("R_output","loo_velocity_binom.Rdata"))
  }else
    {
loo_00<-loo(mod_00)
loo_100<-loo(mod_100)
loo_00_K<-loo(mod_00_K)
loo_100_K<-loo(mod_100_K)
loo_00_noDDD<-loo(mod_00_noDDD)
loo_100_noDDD<-loo(mod_100_noDDD)

save(list=c("loo_100","loo_100_K","loo_100_noDDD",
            "loo_00","loo_00_K","loo_00_noDDD"), 
     file=here("R_output","loo_velocity_binom.Rdata"))
    }


loo_compare(loo_00,loo_100,
            loo_00_K, loo_100_K,
            loo_00_noDDD,loo_100_noDDD) %>%  ##zero doubt the evol model is better
  as.data.frame() %>% 
  rownames_to_column(var="model_name") %>% 
  as_tibble() %>% 
             mutate(is.evo=case_when(str_detect(model_name,"_100")~"after evolution (t = 100)",
                                     T~"before evolution (t = 0)"),
                    is.DDD=case_when(str_detect(model_name,"_noDDD")~"ignored",
                                     str_detect(model_name,"_K")~"included (shape-indep.)",
                                     T~"included (shape-dep.)")) %>% 
  ggplot()+
  geom_pointinterval(aes(is.evo,elpd_diff,
                         ymin=elpd_diff-2*se_diff,
                         ymax=elpd_diff+2*se_diff,
                         col=is.DDD),
                     size=3)+
  geom_line(aes(is.evo,elpd_diff,
                group=is.DDD,
                col=is.DDD))+
  scale_x_discrete("when are trait covariables sampled?")+
  scale_y_continuous("difference in elpd vs. best model")+
  labs(col="Density dependence?")
```


```{r}
if(file.exists(here("R_output","R2_velocity_binom.Rdata"))){
  load(here("R_output","R2_velocity_binom.Rdata"))
  }else
    {
R2_100<-loo_R2(mod_100,summary=FALSE) %>% mean_hdi(R2)
R2_100_K<-loo_R2(mod_100_K,summary=FALSE) %>% mean_hdi(R2)
R2_100_noDDD<-loo_R2(mod_100_noDDD,summary=FALSE) %>% mean_hdi(R2)
R2_00<-loo_R2(mod_00,summary=FALSE) %>% mean_hdi(R2)
R2_00_K<-loo_R2(mod_00_K,summary=FALSE) %>% mean_hdi(R2)
R2_00_noDDD<-loo_R2(mod_00_noDDD,summary=FALSE) %>% mean_hdi(R2)

R2_velocity=rbind(R2_100,R2_100_K,R2_100_noDDD,R2_00,R2_00_K,R2_00_noDDD) %>% 
  mutate(model_name=c("mod_100","mod_100_K","mod_100_noDDD","mod_00","mod_00_K","mod_00_noDDD"))

save(list=c("R2_velocity"), 
     file=here("R_output","R2_velocity_binom.Rdata"))
    }

R2_velocity %>% 
             mutate(is.evo=case_when(str_detect(model_name,"_100")~"after evolution (t = 100)",
                                     T~"before evolution (t = 0)"),
                    is.DDD=case_when(str_detect(model_name,"_noDDD")~"ignored",
                                     str_detect(model_name,"_K")~"included (shape-indep.)",
                                     T~"included (shape-dep.)")) %>% 
  ggplot()+
  geom_pointinterval(aes(is.evo,y,
                         ymin=ymin,
                         ymax=ymax,
                         col=is.DDD),
                     size=3)+
  geom_line(aes(is.evo,y,
                group=is.DDD,
                col=is.DDD))+
  scale_x_discrete("when are trait covariables sampled?")+
  scale_y_continuous("LOO-R2")+
  labs(col="Density dependence?")

```


models ignoring DDD and or evolution still have good predictive power overall (in no small part due to the large proportion of replicates with no evolution and no DDD), but going beyond d0 to predict speed, and accounting for evolutionary change, greatly increase explanatory power
```{r}
pp_check(mod_100) 
pp_check(mod_100_noDDD) 
pp_check(mod_00) 
pp_check(mod_00_noDDD) 
```

seems like data are underdispersed relative to the binomial, for all four models
see comment from bob carpenter here: https://discourse.mc-stan.org/t/underdispersed-binomial-glm/1540
the idea that if underdispersed relative to binomial, then not the result of independent bernoulli trials
which make sense, since proba of advancing to N+1 depends on # of individuals that advanced to N
qualitative ccl are the same anyway though
an ordinal model may be appropriate instead
see eg https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#underdispersion
so let's go with that as a check (supplement?)

```{r}
if(file.exists(here("R_output","models_velocity_ordinal.Rdata"))){
  load(here("R_output","models_velocity_ordinal.Rdata"))
  }else
    {
mod_00_ordinal=brm(bf((advance+1)~ ##we need the +1 because lower category must be 1 in an ordinal
          (scale_d0_start+s_avgslope_start)*mortality),
        family=sratio,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_00_noDDD_ordinal=brm(bf((advance+1)~
          (scale_d0_start)*mortality),
        family=sratio,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")


mod_100_ordinal=brm(bf((advance+1)~
          (scale_d0_100+s_avgslope_100)*mortality),
        family=sratio,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_100_noDDD_ordinal=brm(bf((advance+1)~
          (scale_d0_100)*mortality),
        family=sratio,data=tab,prior=prior_velocity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

save(list=c("mod_100_ordinal","mod_100_noDDD_ordinal",
            "mod_00_ordinal","mod_00_noDDD_ordinal"), 
     file=here("R_output","models_velocity_ordinal.Rdata"))
    }
```


```{r}
if(file.exists(here("R_output","loo_velocity_ordinal.Rdata"))){
  load(here("R_output","loo_velocity_ordinal.Rdata"))
  }else
    {
loo_00_ordinal<-loo(mod_00_ordinal)
loo_100_ordinal<-loo(mod_100_ordinal)
loo_00_noDDD_ordinal<-loo(mod_00_noDDD_ordinal)
loo_100_noDDD_ordinal<-loo(mod_100_noDDD_ordinal)

save(list=c("loo_100_ordinal","loo_100_noDDD_ordinal",
            "loo_00_ordinal","loo_00_noDDD_ordinal"), 
     file=here("R_output","loo_velocity_ordinal.Rdata"))
    }
```
same conclusions as the binomial, so we're good!!





```{r}
plot(conditional_effects(mod_100))
```

let's do proper plot later

## genetic evidence

```{r}
tab$time_to_fix_class=as.numeric(as.factor(tab$time_to_fix))

prior_diversity<-c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        )
```


```{r}
if(file.exists(here("R_output","models_diversity.Rdata"))){
  load(here("R_output","models_diversity.Rdata"))
  }else
    {
mod_div_00=brm(time_to_fix_class~(scale_d0_start+s_avgslope_start)*mortality,
        family=sratio, ##sequential, equivalent to cratio formulation if link logit or probit, see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

### descibre plot as log-odds of genetic diversity persisting at edge beyond current obs
### effect on log-odds of moving anotehr patch

mod_div_00_K=brm(time_to_fix_class~(scale_d0_start+s_Kslope_start)*mortality,
        family=sratio, ##sequential, equivalent to cratio formulation if link logit or probit, see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_div_100=brm(time_to_fix_class~(scale_d0_100+s_avgslope_100)*mortality,
        family=sratio, ##another distri? another link??? see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_div_100_K=brm(time_to_fix_class~(scale_d0_100+s_Kslope_100)*mortality,
        family=sratio, ##another distri? another link??? see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_div_00_noDDD=brm(time_to_fix_class~(scale_d0_start)*mortality,
        family=sratio, ##sequential, equivalent to cratio formulation if link logit or probit, see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

mod_div_100_noDDD=brm(time_to_fix_class~(scale_d0_100)*mortality,
        family=sratio, ##another distri? another link??? see burkner vuorre
        data=filter(tab,front_120>0),#one front did not advance
        prior=prior_diversity,
        chains=4,seed=42,iter=2000,backend="cmdstanr")

save(list=c("mod_div_100","mod_div_100_K","mod_div_100_noDDD",
            "mod_div_00","mod_div_00_K","mod_div_00_noDDD"), 
     file=here("R_output","models_diversity.Rdata"))
    }
```


```{r}
### interesting that model based on start trait seems to be better supported for genet
### makes kinda sense, given mode for fixation is "between 10 and 20 generations"
### but still conclusion re: slope stay consistent
if(file.exists(here("R_output","loo_diversity.Rdata"))){
  load(here("R_output","loo_diversity.Rdata"))
  }else
    {
loo_div_00<-loo(mod_div_00)
loo_div_100<-loo(mod_div_100)
loo_div_00_K<-loo(mod_div_00_K)
loo_div_100_K<-loo(mod_div_100_K)
loo_div_00_noDDD<-loo(mod_div_00_noDDD)
loo_div_100_noDDD<-loo(mod_div_100_noDDD)

save(list=c("loo_div_100","loo_div_100_K","loo_div_100_noDDD",
            "loo_div_00","loo_div_00_K","loo_div_00_noDDD"), 
     file=here("R_output","loo_diversity.Rdata"))
    }

loo_compare(loo_div_00,loo_div_00_K,
            loo_div_100,loo_div_100_K,
            loo_div_00_noDDD,loo_div_100_noDDD) %>% 
  as.data.frame() %>% 
  rownames_to_column(var="model_name") %>% 
  as_tibble() %>% 
             mutate(is.evo=case_when(str_detect(model_name,"_100")~"after evolution (t = 100)",
                                     T~"before evolution (t = 0)"),
                    is.DDD=case_when(str_detect(model_name,"_noDDD")~"ignored",
                                     str_detect(model_name,"_K")~"included (shape-indep.)",
                                     T~"included (shape-dep.)"))  %>% 
  ggplot()+
  geom_pointinterval(aes(is.evo,elpd_diff,
                         ymin=elpd_diff-2*se_diff,
                         ymax=elpd_diff+2*se_diff,
                         col=is.DDD),
                     size=3)+
  geom_line(aes(is.evo,elpd_diff,
                group=is.DDD,
                col=is.DDD))+
  scale_x_discrete("when are trait covariables sampled?")+
  scale_y_continuous("difference in elpd vs. best model")+
  labs(col="Density dependence?")

```

```{r}
if(file.exists(here("R_output","R2_diversity.Rdata"))){
  load(here("R_output","R2_diversity.Rdata"))
  }else
    {
R2_div_100<-loo_R2(mod_div_100,summary=FALSE) %>% mean_hdi(R2)
R2_div_100_K<-loo_R2(mod_div_100_K,summary=FALSE) %>% mean_hdi(R2)
R2_div_100_noDDD<-loo_R2(mod_div_100_noDDD,summary=FALSE) %>% mean_hdi(R2)
R2_div_00<-loo_R2(mod_div_00,summary=FALSE) %>% mean_hdi(R2)
R2_div_00_K<-loo_R2(mod_div_00_K,summary=FALSE) %>% mean_hdi(R2)
R2_div_00_noDDD<-loo_R2(mod_div_00_noDDD,summary=FALSE) %>% mean_hdi(R2)

R2_diversity=rbind(R2_div_100,R2_div_100_K,R2_div_100_noDDD,
                   R2_div_00,R2_div_00_K,R2_div_00_noDDD) %>% 
  mutate(model_name=c("mod_div_100","mod_div_100_K","mod_div_100_noDDD",
                      "mod_div_00","mod_div_00_K","mod_div_00_noDDD"))

save(list=c("R2_diversity"), 
     file=here("R_output","R2_diversity.Rdata"))
    }

R2_diversity %>% 
             mutate(is.evo=case_when(str_detect(model_name,"_100")~"after evolution (t = 100)",
                                     T~"before evolution (t = 0)"),
                    is.DDD=case_when(str_detect(model_name,"_noDDD")~"ignored",
                                     str_detect(model_name,"_K")~"included (shape-indep.)",
                                     T~"included (shape-dep.)"))  %>% 
  ggplot()+
  geom_pointinterval(aes(is.evo,y,
                         ymin=ymin,
                         ymax=ymax,
                         col=is.DDD),
                     size=3)+
  geom_line(aes(is.evo,y,
                group=is.DDD,
                col=is.DDD))+
  scale_x_discrete("when are trait covariables sampled?")+
  scale_y_continuous("LOO-R2")+
  labs(col="Density dependence?")

```


```{r}
plot(conditional_effects(mod_div_00))
```



# analyse evolution

our main tool: the plot y-x~x where y=trait after evol, x=trait at t0, deviation from nthe line y-x=0 indicate evolution

```{r}
tab_evol<- rbind(tab_edge,tab_core) %>% ##check the join is correct
  left_join(tab_start) %>% 
  mutate(group=paste(dispersal_mortality, is.VP_DDD,is.VP_dmax,heritability,where))
```


```{r}
tab_evol2=tab_evol %>% 
  filter(heritability>0)

mod=brm(bf(mean_avgslope_100~b+(1+a)*start_avgslope,
           a~0+group,
           b~0+group,
           sigma~0+group,
           nl=TRUE),data=tab_evol2,
        chains=4,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1)",nlpar=c("a","b")),
          set_prior("normal(0,1)",dpar="sigma")),
        seed=42
        )

```



```{r}
tab_evol2 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  expand_grid(start_avgslope=c(-20:20)/100) %>% 
  add_fitted_draws(mod) %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(data=tab_evol,aes(start_avgslope,
                    mean_avgslope_100-start_avgslope,
                   col=where),alpha=0.5)+
  stat_lineribbon(aes(start_avgslope,
                    .value-start_avgslope,
                   fill=where,col=where),.width=c(0.001,0.95),alpha=0.5)+
    facet_grid(rows=vars(dispersal_mortality,paste("Vdmax",is.VP_dmax)),
               cols=vars(heritability,paste("Vddd",is.VP_DDD)))
```

```{r}

tab_evol4=tab_evol %>% 
  filter(heritability>0) %>% 
  filter(is.VP_DDD>0)

mod2=brm(bf(mean_uncond_100~b+(1+a)*start_uncond,
           a~0+group,
           b~0+group,
           sigma~0+group,
           nl=TRUE),data=tab_evol4,
        chains=4,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1)",nlpar=c("a","b")),
          set_prior("normal(0,1)",dpar="sigma")),
        seed=42
        )
```


```{r}
tab_evol4 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  expand_grid(start_uncond=c(0:100)/100) %>% 
  add_fitted_draws(mod2) %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(data=tab_evol,aes(start_uncond,
                    mean_uncond_100-start_uncond,
                   col=where),alpha=0.5)+
  stat_lineribbon(aes(start_uncond,
                    .value-start_uncond,
                   fill=where,col=where),.width=c(0.001,0.95),alpha=0.5)+
    facet_grid(rows=vars(dispersal_mortality,paste("Vdmax",is.VP_dmax)),
               cols=vars(heritability,paste("Vddd",is.VP_DDD)))
```

```{r}
tab_evol4 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  add_fitted_draws(mod2,dpar="sigma") %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  stat_eye(aes(where,.value,fill=where),.width=c(0.001,0.95))+
    facet_grid(rows=vars(dispersal_mortality,paste("Vdmax",is.VP_dmax)),
               cols=vars(heritability,paste("Vddd",is.VP_DDD)))

```

```{r}
tab_evol3=subset(tab_evol2,is.VP_dmax>0)
#### we need to remove the no evol groups for estimation (because no variance)

mod_dmax=brm(bf(mean_dmax_100~0+group,
           nlf(phi~1/exp(logphi)),
           logphi~0+group,family=Beta),
           data=tab_evol3,
        chains=4,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class=c("b")),
          set_prior("normal(0,1)",nlpar="logphi")),
        seed=42
        )
```

```{r}
tab_evol3 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  add_fitted_draws(mod_dmax) %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  geom_jitter(data=tab_evol,aes(x=where,
                    mean_dmax_100-0.5,
                   col=where),alpha=0.5,height=0)+
  stat_eye(aes(where,
                    .value-0.5),.width=c(0.001,0.95))+
    facet_grid(rows=vars(dispersal_mortality,paste("Vdmax",is.VP_dmax)),
               cols=vars(heritability,paste("Vddd",is.VP_DDD)))

```

```{r}
tab_evol3 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  add_fitted_draws(mod_dmax,nlpar="logphi") %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  stat_eye(aes(where,1/exp(.value),fill=where),.width=c(0.001,0.95))+
    facet_grid(rows=vars(dispersal_mortality,paste("Vdmax",is.VP_dmax)),
               cols=vars(heritability,paste("Vddd",is.VP_DDD)))

```

presenting this way (y-x~x rather than y~x) helps interpret:
in the case of DDD, the main conclusion of erm phillips seems to apply only 
for a narrow set of scenarios:
low cost of dispersal, no/low variation in enhancing/enabling trait, only in matching trait sensu cote 2017
because of spatial sorting, if matching trait, response may even be the reverse (pushed become more pushed)
the exact balance probably depends on the relative amounts of variance in the two types of traits
and the actual fitness benefits of dispersing in the expanding context
which would likely depend on trade-off between dispersal/life-history (pace of life)
and their own DDD, things we haven't tackled here

no shift to DDD-: incomplete

our model is clearly incomplete (trade-offs, phenotypic syndromes, sexual repro, differences in variance and h2 bw enhancing and matching traits), but it does suggest that the parts of the dimension space that allow for the evolutionary maintenance of pushiness
is bigge rthan previously thought

consistency with experiments: when matching only evolve, we find results qualitatively compatible with Trichogramma experiments: from initial DDD+, shift to less DDD+ (or even DDD- in the study) when costs are low, but maintenance of DDD when costs are hhigh (suggest limited evolution of across the board dispersal in trichogramma, something that is again compatible with experiments)

hypotheses: high costs favouring DDD+ (travis 09) (but what about the core)
 runaway effect of spatial sorting if dmax variable?


core tends toward convergence (but why no maintenance of DDD+ at high mortality, contrary to edge and
theory??? suggestion: low variation in density in core):

```{r}
ggplot(tab_evol)+
    geom_boxplot(aes(x=where,y=range_N))+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))
```

