---
title: 'Pushed expansions and sources of variation- individual-based model, data analysis'
author: "Maxime Dahirel & Chlo√© Guicharnaud"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(arm)
library(matrixStats)
library(tidyverse)
#library(mgcv)
#library(gratia)
library(cowplot)
library(patchwork)
library(tidybayes)


library(cmdstanr)
library(brms)
options(mc.cores = 4)

library(tidyverse)

library(here)
```

discussion thread to follow:
sources of evo available as constraints
compatibility between "yes, evo favours mostly DID over the range" BUT "still DDD+ over all, so still open to pushiness, especially if dmax increase", despite apparent paradox
general result still loss of pushiness in many cases, but only if genet div in matching traits (vs enhancing traits)
dispersal costs and heritability influence the dynamics
the DDD+ to DDD- pattern seen in a few studies is not recovered here (well it is, but not in a systematic way)
what's missing? obvious answer: evolution of life history, trade-offs...

# Introduction

```{r}
data <- read_csv(here("NetLogo_output","model-output.csv"))
```

<!--the classical result that costs = more DDD was in contexts where dmax and midpoint did not evolve-->
<!-- hyper important to understand eco-evo dynamics: check that N=0 cells within pops are not deleted-->

<!--key thing to do, check that the effect of absolute slope on speed/diversity is the same independently of source of variation (dmax only, matching only, both) or else difficult to compare their evol dynamics-->

```{r}
data<- data  %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  filter(ticks!=10)
```


# checking pushiness



if convergence at g100, then we can make the following assumptions

-speed over g100-120 is predicted by d0 at g100. The shape of the curve is likely nonlinear, we'll avoid having to seek a correct form by using GAM

-deviations from the d0 prediction are expected, and explained by DDD, DDD+ = faster than expected based on d0, beased on pushiness

-mortality plays a role


```{r}

tab_genet <- data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor >= front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    N_allele0=sum(N_allele0_post),
    N_allele1=sum(N_allele1_post)
  ) %>% 
  ungroup() %>% 
  mutate(edge_fix= N_allele0==0 | N_allele1==0) %>% 
  group_by(replicateID) %>% 
  mutate(time_to_fix=case_when(subset(edge_fix,ticks==20)==1 ~ 20,
                               subset(edge_fix,ticks==40)==1 ~ 40,
                               subset(edge_fix,ticks==60)==1 ~ 60,
                               subset(edge_fix,ticks==80)==1 ~ 80,
                               subset(edge_fix,ticks==100)==1 ~ 100,
                               subset(edge_fix,ticks==120)==1 ~ 120,
                               T~121)##not fixed yet at end of experiment
         ) %>% 
  ungroup() %>% 
  group_by(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(time_to_fix=unique(time_to_fix)) %>% 
  ungroup()



tab_edge<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor >= front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_uncond,front)) %>% 
  mutate(where="edge")

tab_core<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor < 5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_uncond,front)) %>% 
  mutate(where="core")

tab_start<-data %>% select(
  start_dmax,
  start_midpoint,
  start_slope,
  start_d0,
  start_avgslope=start_slopeA_0_avg,
  start_uncond=start_uncond_0_K,
  replicateID
) %>% 
  distinct()

```



```{r}
test<-tab_edge %>% 
  left_join(tab_start) %>% 
  mutate(mortality=factor(dispersal_mortality)) %>% 
  mutate(advance=front_120-front_100) %>% 
  mutate(scale_d0_100=scale(mean_d0_100)[,1],
         scale_d0_start=scale(start_d0)[,1],
         s_avgslope_100=mean_avgslope_100/sd(mean_avgslope_100),
         s_avgslope_start=start_avgslope/sd(start_avgslope))




### reread the burkner vuorre in detail to choose best family of ordinal
### but sequential seems the most appropriate
mod00=brm(bf((advance+1)~
          (scale_d0_start+s_avgslope_start)*mortality),
        family=sratio,data=test,
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

mod00_noDDD=brm(bf((advance+1)~
          (scale_d0_start)*mortality),
        family=sratio,data=test,
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))


mod100=brm(bf((advance+1)~
          (scale_d0_100+s_avgslope_100)*mortality),
        family=sratio,data=test,
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

mod100_noDDD=brm(bf((advance+1)~
          (scale_d0_100)*mortality),
        family=sratio,data=test,
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

loo00<-loo(mod00)
loo100<-loo(mod100)
loo00_noDDD<-loo(mod00_noDDD)
loo100_noDDD<-loo(mod100_noDDD)

loo_compare(loo00,loo100,loo00_noDDD,loo100_noDDD) %>%  ##zero doubt the evol model is better
  as_tibble() %>% 
             mutate(is.evo=c(1,1,0,0),
                  is.DDD=c(1,0,1,0)) %>% 
  ggplot()+
  geom_pointinterval(aes(is.evo,elpd_diff,ymin=elpd_diff-se_diff,ymax=elpd_diff+se_diff,col=factor(is.DDD)),size=3)+
  geom_line(aes(is.evo,elpd_diff,group=is.DDD,col=factor(is.DDD)))

r2mods=test %>% 
  select(c(advance,scale_d0_100,s_avgslope_100,
           scale_d0_start, s_avgslope_start,
           mortality,replicateID)) %>% 
  group_by(replicateID) %>% 
  nest() %>% 
  mutate(mu100=map(.x=data,
                .f=~.x %>% 
                  add_fitted_draws(mod100) %>%
                  mutate(.category=as.numeric(.category)) %>%
                  group_by(.draw) %>%
                  mutate(mu100=.category*.value) %>%
                  summarise(mu100=sum(mu100)) %>% 
                  ungroup() %>% 
                  summarise(mu100=mean(mu100)) %>% ungroup()
  )) %>% 
    mutate(mu00=map(.x=data,
                .f=~.x %>% 
                  add_fitted_draws(mod00) %>%
                  mutate(.category=as.numeric(.category)) %>%
                  group_by(.draw) %>%
                  mutate(mu00=.category*.value) %>%
                  summarise(mu00=sum(mu00)) %>% 
                  ungroup() %>% 
                  summarise(mu00=mean(mu00)) %>% ungroup()
  )) %>%  
  mutate(mu100_noDDD=map(.x=data,
                .f=~.x %>% 
                  add_fitted_draws(mod100_noDDD) %>%
                  mutate(.category=as.numeric(.category)) %>%
                  group_by(.draw) %>%
                  mutate(mu100_noDDD=.category*.value) %>%
                  summarise(mu100_noDDD=sum(mu100_noDDD)) %>% 
                  ungroup() %>% 
                  summarise(mu100_noDDD=mean(mu100_noDDD)) %>% ungroup()
  )) %>% 
    mutate(mu00_noDDD=map(.x=data,
                .f=~.x %>% 
                  add_fitted_draws(mod00_noDDD) %>%
                  mutate(.category=as.numeric(.category)) %>%
                  group_by(.draw) %>%
                  mutate(mu00_noDDD=.category*.value) %>%
                  summarise(mu00_noDDD=sum(mu00_noDDD)) %>% 
                  ungroup() %>% 
                  summarise(mu00_noDDD=mean(mu00_noDDD)) %>% ungroup()
  )) %>% 
  unnest(c(data,mu100,mu00,mu100_noDDD,mu00_noDDD)) %>% 
  ungroup() %>% ##important 
  summarise(r2_00=cor(advance+1,mu00)^2,
            r2_100=cor(advance+1,mu100)^2,
            r2_00_noDDD=cor(advance+1,mu00_noDDD)^2,
            r2_100_noDDD=cor(advance+1,mu100_noDDD)^2)


mod100binom=brm(bf(advance|trials(20)~
          (scale_d0_100+s_avgslope_100)*mortality),
        family=binomial,data=test,
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

pp_check(mod100,"stat_2d")
pp_check(mod100binom,"stat_2d")
### the ordered logit seems to do way better than the binomial, 
### seems like data are underdispersed relative to the binomial
### see comment from bob carpenter here: https://discourse.mc-stan.org/t/underdispersed-binomial-glm/1540
### the idea that if underdispersed relative to binomial, then not the result of independent bernoulli reals
### which make sense, since proba of advancing to N+1 depends on # of individuals that advanced to N
### qualitative ccl are the same anyway though
```



models ignoring DDD and or evolution still have good predictive power overall (in no small part due to the large proportion of replicates with no evolution and no DDD), but going beyond d0 to predict speed, and accounting for evolutionary change, greatly increase explanatory power
in our system, most of the power gain is within the first generations: rapid evolutionary change (how transferable??)




```{r}

test$time_to_fix_class=as.numeric(as.factor(test$time_to_fix))
###needs to separate fixed in 100-120 from not yet fixed at 120

mod_div00=brm(time_to_fix_class~(scale_d0_start+s_avgslope_start)*mortality,
        family=sratio, ##sequential, equivalent to cratio formulation if link logit or probit, see burkner vuorre
        data=filter(test,front_120>0),#one front did not advance
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

### descibre plot as log-odds of genetic diversity persisting at edge beyond current obs
### effect on log-odds of moving anotehr patch

mod_div100=brm(time_to_fix_class~(scale_d0_100+s_avgslope_100)*mortality,
        family=sratio, ##another distri? another link??? see burkner vuorre
        data=filter(test,front_120>0),#one front did not advance
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))


mod_div00_noDDD=brm(time_to_fix_class~(scale_d0_start)*mortality,
        family=sratio, ##sequential, equivalent to cratio formulation if link logit or probit, see burkner vuorre
        data=filter(test,front_120>0),#one front did not advance
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))

mod_div100_noDDD=brm(time_to_fix_class~(scale_d0_100)*mortality,
        family=sratio, ##another distri? another link??? see burkner vuorre
        data=filter(test,front_120>0),#one front did not advance
        chains=4,seed=42,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1.5)",class="Intercept"),
          set_prior("normal(0,1)",class="b")
        ))





### interesting that model based on start trait seems to be better supported for genet
### makes kinda sense, given mode for fixation is "between 10 and 20 generations"
### but still conclusion re: slope stay consistent

loo_div00<-loo(mod_div00)
loo_div100<-loo(mod_div100)
loo_div00_noDDD<-loo(mod_div00_noDDD)
loo_div100_noDDD<-loo(mod_div100_noDDD)
loo_compare(loo_div00,loo_div100,loo_div00_noDDD,loo_div100_noDDD)
## justification: se e.g. roques 2012 for the idea that in (more) pushed expansions, speed of one fraction = to speed of whole expansion, + distance to fixation = integrator of time to fixation
### reason why the post evol model works better here (where it is less obvious than for the speed)
### evol happens fast in this system mostly in the first 10-20 generations, so most of the expansion happens post evol

```





# checking evolutionary and velocity convergence


```{r}
tab_dynamics<-data %>% 
  group_by(replicateID,ticks,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability) %>% 
  summarise(front=max(pxcor*(N_postdispersal>0))) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  arrange(ticks) %>% 
  mutate(prev_front=lag(front)) %>% 
  mutate(prev_front=replace_na(prev_front,0)) %>% 
  mutate(speed_segment=(front-prev_front)/20) %>% 
  mutate(overall_speed=subset(front,ticks==120)/120) %>% 
  ungroup()

  ggplot(tab_dynamics)+
  geom_boxplot(aes(factor(ticks),speed_segment-overall_speed))+
  #facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
  #             cols=vars(heritability,is.VP_DDD))+
  scale_y_continuous("deviation from overall velocity (in patches per generation)")+
  scale_x_discrete("time interval (generations)",
                   labels=c("0-20","20-40","40-60","60-80","80-100","100-120"))+
  theme(legend.position = "none")

```




takeaway: convergence in speed (which depends on both the stochasticity of the invasion smoothing itself out and the evolutionary process finishing) is fast, and speeds at g100 or g120 can reasonably be used as measures of long-run speed

let's do the same to look at evolutionary stability at the edge


```{r}
data %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  select(pxcor,ticks,heritability,is.VP_dmax,is.VP_DDD,replicateID,present_front,dispersal_mortality,
         var_dmax,var_midpoint,var_slope, VP_slope,VP_midpoint,VP_logit_dmax,
         var_genotype_logit_dmax,var_genotype_midpoint,var_genotype_slope,
         var_noise_logit_dmax,var_noise_midpoint,var_noise_slope) %>%
  filter(pxcor==present_front-5) %>%  
  group_by(replicateID) %>% 
  filter(ticks>=100 |ticks==1) %>% 
  mutate(relative_v=(var_slope)) %>%  ##initial variances: logitdmax 1.5^2, slope 6^2, midpoint 0.5^2
  ungroup() %>% 
  ggplot()+
  geom_line(aes(ticks,relative_v,group=replicateID),col="lightgrey")+
  stat_lineribbon(aes(ticks,relative_v),.width=c(0.001,0.95),point_interval = median_qi,
                  alpha=0.5)+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+
  geom_hline(aes(yintercept = (1-heritability)*VP_slope),lty=2,col="red")+
  geom_hline(aes(yintercept = VP_slope),lty=2,col="red")+
  scale_y_continuous("proportion of initial VP remaining")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")
```

(we can NOT use "check if vA falls to zero" as a check for evolutionary stability, because in case of branching within a replicate, dynamics can be stable but vA very high, even higher than at t0 if "core" of the genotypic distri has been carved out)
(well we can, but we have to caveat it)

lots of things to do to strengthen this, but we can carry on assuming convergence at g100 for the enxt steps



# analyse evolution

our main tool: the plot(y=trait after evol, x=trait at t0), deviation from nthe line y=x indicate evolution

```{r}
tab_evol<- rbind(tab_edge,tab_core) %>% ##check the join is correct
  left_join(tab_start) %>% 
  mutate(group=paste(dispersal_mortality, is.VP_DDD,is.VP_dmax,heritability,where))
```


```{r}
tab_evol2=tab_evol %>% 
  filter(heritability>0)

mod=brm(bf(mean_avgslope_100~b+(1+a)*start_avgslope,
           a~0+group,
           b~0+group,
           sigma~0+group,
           nl=TRUE),data=tab_evol2,
        chains=4,iter=2000,backend="cmdstanr",
        prior=c(
          set_prior("normal(0,1)",nlpar=c("a","b")),
          set_prior("normal(0,1)",dpar="sigma")),
        seed=42
        )

```



```{r}
tab_evol2 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  expand_grid(start_avgslope=c(-20:20)/100) %>% 
  add_fitted_draws(mod) %>% 
  ungroup() %>% 
  ggplot()+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(data=tab_evol,aes(start_avgslope,
                    mean_avgslope_100-start_avgslope,
                   col=where),alpha=0.5)+
  stat_lineribbon(aes(start_avgslope,
                    .value-start_avgslope,
                   fill=where,col=where),.width=c(0.001,0.95),alpha=0.5)+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))
```


presenting this way (y-x~x rather than y~x) helps interpret:
in the case of DDD, the main conclusion of erm phillips seems to apply only 
for a narrow set of scenarios:
low cost of dispersal, no/low variation in enhancing/enabling trait, only in matching trait sensu cote 2017
because of spatial sorting, if matching trait, response may even be the reverse (pushed become more pushed)
the exact balance probably depends on the relative amounts of variance in the two types of traits
and the actual fitness benefits of dispersing in the expanding context
which would likely depend on trade-off between dispersal/life-history (pace of life)
and their own DDD, things we haven't tackled here

no shift to DDD-: incomplete

our model is clearly incomplete (trade-offs, phenotypic syndromes, sexual repro, differences in variance and h2 bw enhancing and matching traits), but it does suggest that the parts of the dimension space that allow for the evolutionary maintenance of pushiness
is bigge rthan previously thought

consistency with experiments: when matching only evolve, we find results qualitatively compatible with Trichogramma experiments: from initial DDD+, shift to less DDD+ (or even DDD- in the study) when costs are low, but maintenance of DDD when costs are hhigh (suggest limited evolution of across the board dispersal in trichogramma, something that is again compatible with experiments)

hypotheses: high costs favouring DDD+ (travis 09) (but what about the core)
 runaway effect of spatial sorting if dmax variable?


core tends toward convergence (but why no maintenance of DDD+ at high mortality, contrary to edge and
theory??? suggestion: low variation in density in core)

```{r}
tab_evol2 %>% 
  select(dispersal_mortality,is.VP_DDD,is.VP_dmax,heritability,where,group) %>% 
  distinct() %>% 
  mutate(start_avgslope=0) %>% 
  add_fitted_draws(mod,dpar="sigma") %>% 
  ungroup() %>% 
  ggplot()+
  stat_eye(aes(x=where,y=sigma,fill=where),.width=c(0.001,0.95),alpha=0.5)+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))
```

looking at sigma, more residual variance 

```{r}
ggplot(tab2)+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(aes(start_uncond_0_K,mean_uncond_0_K-start_uncond_0_K,col=where),alpha=0.1)+
  geom_smooth(aes(start_uncond_0_K,mean_uncond_0_K-start_uncond_0_K,col=where),method="lm")+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
                       cols=vars(heritability,is.VP_DDD))+ 
  scale_x_continuous("original mean unconditionality index",limits = c(0,1))+
  scale_y_continuous("evolutionary change in unconditionality",limits = c(-1,1))+
  cowplot::theme_half_open(11) +
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95")

### consistent evolution towards unconditionality, in line with travis 09
### less strong if mortality +++
### plus nuance that unconditionality does not mean no DDD (depends on N at edge???)

  
ggplot(tab2)+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(aes(start_d0,mean_d0-start_d0,col=where),alpha=0.1)+
  geom_smooth(aes(start_d0,mean_d0-start_d0,col=where),method="lm")+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
                       cols=vars(heritability,is.VP_DDD))+ 
  scale_x_continuous("original mean d0",limits = c(0,1.1))+
  scale_y_continuous("evolutionary change in d0",limits = c(-1,1))+
  cowplot::theme_half_open(11) +
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95")
   

ggplot(tab2)+
    geom_hline(yintercept = 0.5, lty=2)+
    geom_boxplot(aes(y=mean_dmax,col=where))+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+ 
    scale_x_discrete("")+
    scale_y_continuous("final mean dmax",limits = c(0,1))+
  cowplot::theme_half_open(11) +
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95")

```


```{r}

tab3<-tab2 %>% 
  mutate(panel=paste("mort",dispersal_mortality,
                     "vp_dmax",is.VP_dmax,
                     "vp_ddd",is.VP_DDD,
                     "h2",heritability)) %>% 
  select(panel,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,
         mean_slopeA_0_avg,start_slopeA_0_avg,
         mean_uncond0_K,start_uncond0_K,mean_dmax,mean_dmax_start,mean_d0,mean_d0_start,where) %>% 
  group_by(panel,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,where) %>% 
  nest() %>% 
  mutate(lm_ddd=map(.x=data,.f=~lm(mean_slopeA_0_avg~start_slopeA_0_avg,data=.x))) %>% 
  mutate(sigma_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$sigma}),
         slope_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[2,"Estimate"]}),
         slope_ddd_se=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[2,"Std. Error"]}),
         int_ddd=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_ddd_se=map(.x=lm_ddd,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>%   
  mutate(lm_uncond=map(.x=data,.f=~lm(mean_uncond0_K~start_uncond0_K,data=.x))) %>% 
  mutate(sigma_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$sigma}),
         slope_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[2,"Estimate"]}),
         slope_uncond_se=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[2,"Std. Error"]}),
         int_uncond=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_uncond_se=map(.x=lm_uncond,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>%   
  mutate(lm_d0=map(.x=data,.f=~lm(mean_d0~mean_d0_start,data=.x))) %>% 
  mutate(sigma_d0=map(.x=lm_d0,.f=function(.x){summary(.x)$sigma}),
         slope_d0=map(.x=lm_d0,.f=function(.x){summary(.x)$coefficients[2,"Estimate"]}),
         slope_d0_se=map(.x=lm_d0,.f=function(.x){summary(.x)$coefficients[2,"Std. Error"]}),
         int_d0=map(.x=lm_d0,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_d0_se=map(.x=lm_d0,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>% 
  mutate(lm_dmax=map(.x=data,.f=~lm(mean_dmax~1,data=.x))) %>% 
  mutate(sigma_dmax=map(.x=lm_dmax,.f=function(.x){summary(.x)$sigma}),
         int_dmax=map(.x=lm_dmax,.f=function(.x){summary(.x)$coefficients[1,"Estimate"]}),
         int_dmax_se=map(.x=lm_dmax,.f=function(.x){summary(.x)$coefficients[1,"Std. Error"]})
         ) %>%  
  unnest(c(sigma_ddd,slope_ddd,slope_ddd_se,int_ddd,int_ddd_se,
           sigma_uncond,slope_uncond,slope_uncond_se,int_uncond,int_uncond_se,
           sigma_d0,slope_d0,slope_d0_se,int_d0,int_d0_se,
           sigma_dmax,int_dmax,int_dmax_se)) %>% 
  mutate(VP_source=case_when(is.VP_dmax==0 & is.VP_DDD==0~"none",
                             is.VP_dmax==1 & is.VP_DDD==0~"dmax only",
                             is.VP_dmax==0 & is.VP_DDD==1~"DDD only",
                             is.VP_dmax==1 & is.VP_DDD==1~"both")) %>% 
  ungroup()
  
#### plot for DDD
ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=slope_ddd,
                         ymin=slope_ddd-2*slope_ddd_se,ymax=slope_ddd+2*slope_ddd_se,
                   col=where),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=slope_ddd,
                   col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=1,lty=2)+
  facet_grid(cols=vars(heritability),rows=vars(VP_source))+
  coord_cartesian(ylim=c(0,2.5))

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_ddd,
                         ymin=int_ddd-2*int_ddd_se,ymax=int_ddd+2*int_ddd_se,
                   col=where),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_ddd,
                   col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_grid(cols=vars(heritability),rows=vars(VP_source))+
  coord_cartesian(ylim=c(-0.25,0.25))


ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_ddd,col=where),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_ddd,
                   col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_grid(cols=vars(heritability),rows=vars(VP_source))
  

### same plots for uncondition

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=slope_uncond,
                         ymin=slope_uncond-2*slope_uncond_se,ymax=slope_uncond+2*slope_uncond_se,
                   col=where),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=slope_uncond,
                   col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=1,lty=2)+
    facet_grid(cols=vars(heritability),rows=vars(VP_source))+
  coord_cartesian(ylim=c(0,2.5))

ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_uncond,
                         ymin=int_uncond-2*int_uncond_se,ymax=int_uncond+2*int_uncond_se,
                   col=where),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_uncond,
                   col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
    facet_grid(cols=vars(heritability),rows=vars(VP_source))+
  coord_cartesian(ylim=c(0,1))

ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_uncond,col=where),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_uncond,
                    col=where),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
    facet_grid(cols=vars(heritability),rows=vars(VP_source))



### same plots for d0

p1<-ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=slope_d0,
                         ymin=slope_d0-2*slope_d0_se,ymax=slope_d0+2*slope_d0_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=slope_d0,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=1,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(0,3))

p2<-ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_d0,
                         ymin=int_d0-2*int_d0_se,ymax=int_d0+2*int_d0_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_d0,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(-1,1))

p3<-ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_d0,col=VP_source),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_d0,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)
p1/p2/p3
####same for dmax

p1<-ggplot(tab3)+
  geom_pointinterval(aes(x=factor(dispersal_mortality),y=int_dmax,
                         ymin=int_dmax-2*int_dmax_se,ymax=int_dmax+2*int_dmax_se,
                   col=VP_source),position = position_dodge(width=0.25),point_size=2)+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=int_dmax,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)+
  coord_cartesian(ylim=c(-1,1))

p2<-ggplot(tab3)+
  geom_point(aes(x=factor(dispersal_mortality),y=sigma_dmax,col=VP_source),size=2,position = position_dodge(width=0.25))+
  geom_line(aes(x=as.numeric(factor(dispersal_mortality)),y=sigma_dmax,
                   col=VP_source),position = position_dodge(width=0.25))+
  geom_hline(yintercept=0,lty=2)+
  facet_wrap(~heritability)

p1/p2

```

the more a trait is heritable the mor eunconditional the dispfunc becomes, and the stronger the slope becomes

needs to add plots for d0 and dmax to understand the dynamics


alt way of representing the info: deviation:

```{r}
ggplot(tab2)+
    geom_hline(yintercept = 0, lty=2)+
    geom_point(aes(start_slopeA_0_K,mean_slopeA_0_K-start_slopeA_0_K))+
    geom_smooth(aes(start_slopeA_0_K,mean_slopeA_0_K-start_slopeA_0_K),method="lm")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_upper-start_slopeA_0_K),col="red")+
  geom_line(aes(start_slopeA_0_K,start_slopeA_0_K_lower-start_slopeA_0_K),col="red")+
    facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
               cols=vars(heritability,is.VP_DDD))+ 
    scale_x_continuous("original mean absolute slope",limits = c(-1,1))+
    scale_y_continuous("final deviation from original absolute slope",limits = c(-1,1))

  ggplot(tab2)+
  geom_hline(yintercept = 0,lty=2)+
  geom_point(aes(start_uncond0_K,mean_uncond0_K-start_uncond0_K))+
  geom_smooth(aes(start_uncond0_K,mean_uncond0_K-start_uncond0_K),method="lm")+
    geom_line(aes(start_uncond0_K,start_uncond0_K_upper-start_uncond0_K),col="red")+
  geom_line(aes(start_uncond0_K,start_uncond0_K_lower-start_uncond0_K),col="red")+
  facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
                       cols=vars(heritability,is.VP_DDD))+ 
  scale_x_continuous("original mean unconditionality index",limits = c(0,1.1))+
  scale_y_continuous("final deviation from original mean unconditionality index",limits = c(-1.1,1.1))
  

```


## notes ?
Ok it looks like we find the costs+ = ddd++ pattern only when dmax is not allowed to evolve (makes sense, wasn't allowed to in the models that showed this, iirc). But with dmax allowed to evolved, things are more messy


prediction from birzu: pulled waves favour evolution of strats with higher dispersal rate at the edge
can't look at the dispersal function, since N at the edge varies bw types, need to look at actual dispersal events



mmm... mayyyybe? but very dependent on what pxcor we whoose (front-1, front -2...), because N varies quickly. potentially interesting to look at d=f(distance from front)

```{r}
tab4<-tab2 %>% 
  mutate(panel=paste("mort",dispersal_mortality,
                     "vp_dmax",is.VP_dmax,
                     "vp_ddd",is.VP_DDD,
                     "h2",heritability)) %>% 
  select(panel,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,
         mean_slopeA_0_avg,start_slopeA_0_avg,
         mean_uncond0_K,start_uncond0_K,mean_dmax,mean_d0,mean_d0_start) %>% 
  mutate(dev_slope=mean_slopeA_0_avg-start_slopeA_0_avg,
         dev_uncond=mean_uncond0_K-start_uncond0_K,
         dev_d0=mean_d0-mean_d0_start)

cor(tab4[,c("dev_slope","dev_uncond","mean_dmax","dev_d0")],use = "pairwise.complete.obs")
```


