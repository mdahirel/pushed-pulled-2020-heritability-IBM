---
title: 'main analysis code for "Individual variation in dispersal, and its sources, shape the fate of pushed vs. pulled range expansions"'
author: "Maxime Dahirel, Chlo√© Guicharnaud, Elodie Vercken (code by Maxime Dahirel)"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(tidyverse)

library(brms)
library(bayesplot)
library(tidybayes)
options(mc.cores=4)

library(patchwork)   # CRAN v1.1.1

library(here)        # CRAN v1.0.1
```

# Introduction

After running the code in `R/generate_simulations`, we obtained, and saved, a `csv` file containing patch-level data for every simulation we ran. We can now load it, but we're going to immediately make a quick change: in the IBM, phenotypic variance input variables denote, well, the actual phenotypic variances we wanted to input. But since we only tested two levels, variance or no variance, much easier for us to work with binary variables going forward:

```{r import-data}
data <- read_csv(here("NetLogo_output", "simulation_output.csv")) %>%
  mutate(
    is.VP_dmax = as.numeric(VP_logit_dmax > 0),
    is.VP_DDD = as.numeric(VP_slope > 0)
    # if VP_slope >0, then VP_midpoint is also >0 in our experimental design
    # so only one binary variable needed for density-dependent dispersal variables
  )
```

OK, the dataset we just imported is structured so that one row = one patch in one landscape at one observed time. Only patches that were populated at least once are included (see the end of the `generate_simulations` file). The dataset contains many variables, many of them were collected as a precaution "in case they were needed later" (since re-running the models is time consuming); not all of them will be used in the analysis:

- `ticks`: time step at which the observations were made (= number of generations since start)

Landscape-level variables, all constant across time (either because they are truly constant, or because they only describe initial conditions at $t=0$ and are not updated after):
              
- `start_dmax`, `start_slope`, `start_midpoint`: mean dispersal trait values at the start of the experiment (`slope` corresponds to $\alpha$ in the manuscript, `midpoint` to $\beta$)
- `VP_logit_dmax`, `VP_slope`, `VP_midpoint`: **initial** phenotypic variances
- `is.VP_dmax`, `is.VP_DDD`: binary variables describing whether `VP_logit_dmax` on one hand, and `VP_slope` and `VP_midpoint` on the other, are >0
- `heritability`: **initial** heritability (same value for all traits)
- `dispersal_mortality`: probability of dying during dispersal
- `fecundity`: hypothetical average fecundity at $N=0$ ($\exp(r_{0})$)               
- `K`: patch carrying capacity (same for all patches)
- `reproduction`: whether the simulated species was clonal or sexual (here all runs are clonal)
- `seedID`, `siminputrow`, `replicateID`: the first two variables, combined, give the third one: a unique identifier for each landscape/run
- `start_d0`, `start_dK`, `start_davg_0_K`, `start_slopeA_0_K`, `start_slopeA_0_avg`: mean values for $d_{0}$, $d_{K}$, $d_{avg}$,  the density-dependence metrics $\Delta_{K-0}$, $\Delta_{avg-0}$ in the starter population (see <!--SUPPLEMENTARY TO ADD--> for the definition of each of these variables)        
- `start_uncond_0_K`: same as above, for the unconditionality metric (see <!--supplementary to add/edit?--> for the definition of that metric)

- `agent`: here always "patches"                   
- `breed`: here always NA (NetLogo "breeds" are ways to have different discrete groups of individuals that play by different rules. Here there was only one breed, and data are collected at the patch level anyway)                                                  

Patch-level variables:
- `pxcor`: patch $x$ coordinate                   
- `founding`: the generation at which the patch was first populated
- `N_predispersal` and `N_postdispersal`: population size in the patch immediately before and after the dispersal phase, respectively
- `N_sedentary`: number of individuals born in the patch that stayed in it
- `N_disp_dead`: number of individuals born in the patch that died during dispersal             
- `N_allele0_pre`, `N_allele1_pre`, `N_allele0_post`, `N_allele1_post`: number of individuals with each neutral allele, pre- and post-dispersal
- `mean_genotype_logit_dmax`, `var_genotype_logit_dmax`, `mean_genotype_slope`, `var_genotype_slope`, `mean_genotype_midpoint`,  `var_genotype_midpoint`: mean and variances  of the genetic component of traits   
- `mean_dmax`, `mean_slope`, `mean_midpoint`: phenotypic means of the dispersal traits
- `mean_d0`, `mean_dK`, `mean_davg_0_K`, `mean_slopeA_0_K`, `mean_slopeA_0_avg`, `mean_uncond_0_K`: means of dispersal metrics that can be estimated from these dispersal traits (see above)     

# Data wrangling


```{r}

# something for later: a way to use founding column to get info about speed at all generations
# shows that at 120 most seem to have reached equilibrium
data |> select(heritability,fecundity,is.VP_dmax,is.VP_DDD,dispersal_mortality,replicateID,founding,pxcor) |> distinct() |> ggplot()+geom_line(aes(founding,pxcor/founding,group=replicateID,col=factor(heritability)))+scale_x_continuous("t (generations since start)")+scale_y_continuous("expansion speed up to t")+facet_wrap(~fecundity+dispersal_mortality)
```

To do our analyses, we're going to build several "processed" tables from this "raw" dataset, which we'll then merge into a final table.

First: we will only focus on the state of our expansions at the end of the simulations (t = 120). There is good evidence that speed and evolutionary dynamics are at or close to equilibrium for most replicates at this time. <!--DISCUSS IN SUPPLEMENTARY, SEE BONUS PLOT ABOVE, BRING IT TO SUPPLEMENTARY-->

Second: we will consistently use the metrics as captured at the *start* of each generation, i.e. pre-dispersal. This is to avoid trying to interpret non-genetic dynamics in traits that are reset each generation. For instance, if dispersal capacity is variable but 100% non-genetic, there may be an excess of high dispersers in newly colonised patches. This excess will however vanish when they reproduce and dispersal traits are redrawn. In front patches that are funded by a low number of individuals, this also allows us to estimate patch averages for traits and genetic diversity from higher post-reproduction numbers vs. lower founding numbers.


We start by creating a dataset for genetic diversity, with one observation = one replicate expansion. Our metric of genetic diversity is spatial, and based on the positions of the expansion front for the whole expansion vs. for the individuals that bear the neutral allele that lags behind. In addition to this information, we create a `scenario` variable that groups together all replicates that share the same initial conditions (fecundity, mortality, starting values of dispersal traits, their variability and heritability). In creating this genetic diversity variable, we incidentally also create the expansion speed variable (since it is `front`, the location of the farthest individual irrespective of neutral allele identity, divided by `ticks`)

```{r}
tab <- data  |>
  filter(ticks==120) |> # we only keep the last iteration
  filter(N_predispersal>0) |> # for genetic diversity to be measured in a patch, there needs to be individuals
  mutate(scenario=paste0("F=",fecundity, "_M=",dispersal_mortality,
                         "_h2=",heritability,
                     "_slope=",start_slope,"_midpoint=",start_midpoint,
                     "_VP.DDD=",is.VP_DDD,"_VP_dmax=",is.VP_dmax)) |> 
  group_by(replicateID, scenario, ticks, 
           dispersal_mortality, heritability, fecundity,
           is.VP_dmax, is.VP_DDD,
           start_slope, start_midpoint,
           start_d0, start_dK,        
           start_slopeA_0_K) |> 
  summarise(front1 = max(pxcor * (N_allele1_pre > 0), na.rm=TRUE), # the coordinate of the farthest individual with neutral allele 1
            front0 = max(pxcor * (N_allele0_pre > 0), na.rm=TRUE)  # same with neutral allele 0
  ) |> 
  rowwise() |> 
  mutate(front = max(front0, front1),  # which is the farthest of the two irrespective of allele value
         lagging = min( front0, front1) # which is the other?
  ) |> 
  ungroup()
```

We then create a dataset that contain the mean dispersal trait values at time $t$ in the range front (which we defined here semi-arbitrarily as patches < 5 patches from the edge; see <!--Supplementary S2--> for justification).

We first use the previously created dataset to know, for each replicate, which patches are "front patches"

```{r}
tab_intermediate <- tab |> 
  select(replicateID, front)

```

We then use that to (i) filter the big `data` to only keep front patches (ii) and then get weighted averages for each key trait 


```{r}
tab_traits <- data |> 
  filter(ticks==120) |> 
  left_join(tab_intermediate) |> 
  filter(pxcor > (front - 5)) |> 
  group_by(replicateID, ticks)  |> 
  summarise(
    mean_dmax = weighted.mean(mean_dmax, w = N_predispersal, na.rm = TRUE),
    mean_dK = weighted.mean(mean_dK, w = N_predispersal, na.rm = TRUE),
    mean_d0 = weighted.mean(mean_d0, w = N_predispersal, na.rm = TRUE),
    mean_Kslope = weighted.mean(mean_slopeA_0_K, w = N_predispersal, na.rm = TRUE)
  )  |> 
  ungroup()
```

We can then merge the two in one dataset

```{r}
tab <- left_join(tab,tab_traits) |> 
  mutate(Mort=factor(dispersal_mortality),
         Fec=factor(fecundity)
         )
```

```{r}
N_replicates<-length(unique(data$replicateID))
N_non_extinct<-length(unique(tab$replicateID)) 
```


```{r}
tab <- filter(tab, front>0) # we exclude what did not advance
```

```{r}

N_expand<-length(unique(tab$replicateID)) 
```


# Analysis

We can't really combine in one analysis all the simulations: (i) expansions without phenotypic variation, (ii) with only non-heritable phenotypic variation and (iii) where evolution is possible in at least one trait are three "regimes" that are best analysed separately.

So let's split the data:

```{r}

tab_novar = filter(tab, is.VP_DDD ==0 & is.VP_dmax ==0) #(i)

tab_var_noevo = filter(tab,(is.VP_DDD==1 | is.VP_dmax==1) & heritability ==0) #(ii)
tab_var_evo = filter(tab,(is.VP_DDD==1 | is.VP_dmax==1) & heritability >0) #(iii)

dim(tab)[1] == dim(tab_novar)[1] + dim(tab_var_noevo) [1] + dim(tab_var_evo)[1] #sense check

```

For (i) and (ii) there is no reason to analyse phenotypic trait changes, this can only be done meaningfully in (iii)

## non evo models

```{r}
mod_gen_novar=brm(bf(lagging|trials(front)~ start_slopeA_0_K * Mort * Fec  + (1|scenario),
                     nlf(phi~1/invphi),
                     invphi~1),
                  family=beta_binomial(link_phi = "identity"),
                  data=tab_novar,backend="cmdstanr",
        seed=42,
                  prior=c(
                    set_prior("normal(0,1.5)",class="Intercept"),
                    set_prior("normal(0,1)",class="b"),
                    set_prior("normal(0,1)",class="sd"),
                    set_prior("normal(0,1)",class="b",nlpar="invphi",lb=0)
                  )
)



newdata=select(tab_novar,Mort,Fec) |> distinct() |> 
  mutate(front=1) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod_gen_novar,re_formula=NA)

tab_novar |>  
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=lagging/front,size=front),col="lightblue",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_novar |> group_by(scenario,Mort,Fec) |> 
               summarise(div=mean(lagging/front,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,div),size=3)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("how far does genetic diversity persists?")+
  theme_bw()+
  theme(legend.position = "none")
```

```{r}
mod_gen_var_noevo=brm(bf(lagging|trials(front)~ start_slopeA_0_K * Mort * Fec  + (1|scenario),
                     nlf(phi~1/invphi),
                     invphi~1),
                  family=beta_binomial(link_phi = "identity"),
                  data=tab_var_noevo,backend="cmdstanr",
        seed=42,
                  prior=c(
                    set_prior("normal(0,1.5)",class="Intercept"),
                    set_prior("normal(0,1)",class="b"),
                    set_prior("normal(0,1)",class="sd"),
                    set_prior("normal(0,1)",class="b",nlpar="invphi",lb=0)
                  )
)



newdata=select(tab_var_noevo,Mort,Fec) |> distinct() |> 
  mutate(front=1) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod_gen_var_noevo,re_formula=NA)

tab_var_noevo |>  
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=lagging/front,size=front),col="pink",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_noevo |> group_by(scenario,Mort,Fec) |> 
               summarise(div=mean(lagging/front,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,div),size=3)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("how far does genetic diversity persists?")+
  theme_bw()+
  theme(legend.position = "none")
```


```{r}

## a reanalysis to check if effect of fecundity/mortality subsumable into an effect of speed
## mortality reduces speed, fecundity increases speed, so the number of founding events
## first we note that increasing mortality and increasing fecundity have the same effect (reducing div)
## nso unlikely
## but we can rerun using speed as covar
tab_var_noevo$sfront=scale(tab_var_noevo$front)

mod_gen_var_noevo2=brm(bf(lagging|trials(front)~ start_slopeA_0_K * Mort * Fec  + sfront + (1|scenario),
                     nlf(phi~1/invphi),
                     invphi~1),
                  family=beta_binomial(link_phi = "identity"),
                  data=tab_var_noevo,backend="cmdstanr",
        seed=42,
                  prior=c(
                    set_prior("normal(0,1.5)",class="Intercept"),
                    set_prior("normal(0,1)",class="b"),
                    set_prior("normal(0,1)",class="sd"),
                    set_prior("normal(0,1)",class="b",nlpar="invphi",lb=0)
                  )
)



newdata=select(tab_var_noevo,Mort,Fec) |> distinct() |> 
  mutate(front=1,sfront=0) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod_gen_var_noevo2,re_formula=NA)

tab_var_noevo |>  
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=lagging/front,size=front),col="lightgreen",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_noevo |> group_by(scenario,Mort,Fec) |> 
               summarise(div=mean(lagging/front,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,div),size=3)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("how far does genetic diversity persists?")+
  theme_bw()+
  theme(legend.position = "none")
```

## evo models

We use a trivariate approach: we see again how genetic diversity changes in response to initial density-dependence, but also how the DD metric itself evolves, and also dispersal capacity.

we start by setting the priors
```{r}
prior_tri<-c(
          set_prior("normal(0,1.5)",class="Intercept",resp="lagging"),
          set_prior("normal(0,1)",class="b",resp="lagging"),
          set_prior("normal(0,1)",class="sd",resp="lagging"),
          set_prior("normal(0,1)",class="b",resp="lagging",nlpar="invphi",lb=0),
          
          set_prior("normal(0,1)",class="Intercept",resp="meanKslope"),
          set_prior("normal(0,1)",class="b",resp="meanKslope"),
          set_prior("normal(0,1)",class="sd",resp="meanKslope"),
          
          set_prior("normal(0,1.5)",class="Intercept",resp="meandmax"),
          set_prior("normal(0,1)",class="b",resp="meandmax"),
          set_prior("normal(0,1)",class="sd",resp="meandmax"),
          set_prior("normal(0,1)",class="b",resp="meandmax",nlpar="invphi",lb=0),
          
          set_prior("lkj(2)",class="cor")
        )
```

then the model formulas (note that how in the formula for dmax _ and thus in the trait correlations involving dmax _ , we only accept replicates in which dmax can evolve)
```{r}
bf_genet=bf(lagging|trials(front)~ start_slopeA_0_K * Mort * Fec  + (1|p|scenario),
            nlf(phi~1/invphi),
            invphi~1,
            family=beta_binomial(link_phi = "identity"))

bf_slope=bf(mean_Kslope~ start_slopeA_0_K * Mort * Fec  + (1|p|scenario))

bf_dmax=bf(mean_dmax|subset(is.VP_dmax==1)~ start_slopeA_0_K * Mort * Fec + (1|p|scenario),
           nlf(phi~1/invphi),
           invphi~1,
           family=Beta(link_phi = "identity"))
```


```{r}
mod=brm(mvbf(bf_genet,bf_slope,bf_dmax),
        data=tab_var_evo,backend="cmdstanr",
        seed=42,
        prior=prior_tri)
```


we may note that some of the among-traits correlations we see might be primarily driven by dmax evolution. For instance: if the relative shape of the dispersal function cannot evolve, only dmax, then increases in dmax will automatically lead to higher DD by our metric. 

To check whether our correlations are primarily driven by that, we re-run the multivariate model, only using scenarios where only alpha and beta can evolve, not dmax. We logically make that a bivariate model only, since there are no reasons to expect variation in dmax:

```{r}
prior_bi<-c(
          set_prior("normal(0,1.5)",class="Intercept",resp="lagging"),
          set_prior("normal(0,1)",class="b",resp="lagging"),
          set_prior("normal(0,1)",class="sd",resp="lagging"),
          set_prior("normal(0,1)",class="b",resp="lagging",nlpar="invphi",lb=0),
          
          set_prior("normal(0,1)",class="Intercept",resp="meanKslope"),
          set_prior("normal(0,1)",class="b",resp="meanKslope"),
          set_prior("normal(0,1)",class="sd",resp="meanKslope"),
          
          set_prior("lkj(2)",class="cor")
        )
```


```{r}
mod1=brm(mvbf(bf_genet,bf_slope),
        data=subset(tab_var_evo,is.VP_dmax==0),  # only replicates with no dmax evol
        backend="cmdstanr",
        seed=42,
        prior=prior_bi)
```






```{r}

ranef(mod)$scenario[,"Estimate",] |> as_tibble() |>  
  ggplot()+
  geom_point(aes(lagging_Intercept,meanKslope_Intercept))+
  geom_hline(yintercept=0,lty=2)+
  geom_vline(xintercept=0,lty=2)+
  scale_x_continuous("genetic diversity BLUP")+
  scale_y_continuous("dispersal density-dependence BLUP")+
  theme_bw()
```


```{r}

newdata=select(tab_var_evo,Mort,Fec) |> distinct() |> 
  mutate(front=1) |> 
  expand_grid(start_slopeA_0_K=c(-3:3)/10) |> 
  add_epred_draws(mod1,re_formula=NA,resp="meanKslope")

tab_var_evo |>  filter(is.VP_dmax==0) |> 
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=mean_Kslope),col="lightgreen",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_evo |> filter(is.VP_dmax==0) |> group_by(scenario,Mort,Fec) |> 
               summarise(endslope=mean(mean_Kslope,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,endslope),size=3)+
  geom_abline(aes(intercept=0,slope=1),lty=2)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("final slope of DDD")+
  theme_bw()+
  theme(legend.position = "none")
```


```{r}

newdata=select(tab_var_evo,Mort,Fec) |> distinct() |> 
  mutate(front=1) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod,re_formula=NA,resp="meanKslope")

tab_var_evo |>
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=mean_Kslope),col="lightblue",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_evo |> group_by(scenario,Mort,Fec) |> 
               summarise(endslope=mean(mean_Kslope,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,endslope),size=3)+
  geom_abline(aes(intercept=0,slope=1),lty=2)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("final slope of DDD")+
  theme_bw()+
  theme(legend.position = "none")
```


```{r}

newdata=select(tab_var_evo,Mort,Fec) |> distinct() |> 
  mutate(front=1) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod,re_formula=NA,resp="lagging")

tab_var_evo |>  
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=lagging/front,size=front),col="lightgreen",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_evo |> group_by(scenario,Mort,Fec) |> 
               summarise(div=mean(lagging/front,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,div),size=3)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("how far does genetic diversity persists?")+
  theme_bw()+
  theme(legend.position = "none")
```


```{r}

newdata=select(tab_var_evo,Mort,Fec) |> distinct() |> 
  mutate(front=1,is.VP_dmax=1) |> 
  expand_grid(start_slopeA_0_K=c(-5:5)/10) |> 
  add_epred_draws(mod,re_formula=NA,resp="meandmax")

tab_var_evo |> filter(is.VP_dmax==1) |>  
  ggplot()+
  geom_point(aes(x=start_slopeA_0_K,y=mean_dmax,size=front),col="lightgreen",alpha=0.5)+
  stat_lineribbon(data=newdata,aes(x=start_slopeA_0_K,y=.epred),fill="grey",alpha=0.5)+
  geom_point(data=tab_var_evo |> filter(is.VP_dmax==1) |> group_by(scenario,Mort,Fec) |> 
               summarise(dmax=mean(mean_dmax,na.rm=TRUE),
                         slope=mean(start_slopeA_0_K)),
             aes(x=slope,dmax),size=3)+
  geom_hline(yintercept=0.5,lty=2)+
  facet_grid(rows=vars(paste("fecundity(0)=",Fec)),cols=vars(paste("m=",Mort)))+
  scale_x_continuous("initial slope of DDD (mean dK - D0)")+
  scale_y_continuous("how far does genetic diversity persists?")+
  theme_bw()+
  theme(legend.position = "none")
```

