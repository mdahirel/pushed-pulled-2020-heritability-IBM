---
title: 'Pushed expansions and heritability- individual-based model, model creation'
author: "Maxime Dahirel & Chlo√© Guicharnaud"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(nlrx)
library(arm)
library(tidyverse)
library(cowplot)
library(here)
```

# Introduction

<!--to detail-->

# Setup

First, let's tell R where is your NetLogo version, what version number it is, for how many generations do we want the model to run, and how many replicates we want for each parameter combination:

```{r general-information}
####
NLPATH <- "C:/Program Files/NetLogo 6.1.1" # change as needed
NLVERSION <- "6.1.1" # change as needed
nreplicates <- 1 # test run
duration <- 10 # test run
```

We now need to tell R where the actual NetLogo file of the model is (The reader is strongly encouraged to go look at it, especially the Info pane):

```{r model-path}
nl_object <- nl(
  nlversion = NLVERSION, nlpath = NLPATH,
  modelpath = here("NetLogo_model", "range_expansion.nlogo"),
  jvmmem = 1024
)
```


Then, let's set the experimental design. <!--to detail-->

```{r design-grid}
### designing the experiment
trt_grid <- expand_grid(
  slope_disp_mean = c(-1, 0, 1),
  disp0_mean = c(0.1, 0.2),
  heritability = c(0, 0.3, 1),
  variance_pheno = c(0, 1),
  reproduction = "clonal"   # IMPORTANT: ONE of "sexual" or "clonal"
) %>%
  mutate(duplicate_cells = (heritability != 0 & variance_pheno == 0)) %>%
  filter(duplicate_cells == FALSE) %>% ## remove "duplicate" cells
  # (because if V_P=0, then any h^2 will give the same V_A than h^2=0)
  select(-duplicate_cells) %>%
  mutate(
    reproduction_nl = paste('\"',reproduction,'\"',sep=""),# adds the quote and escape needed to export the string to Netlogo
    variance_pheno_logit_disp0 = variance_pheno,
    variance_pheno_disp_slope = variance_pheno,
    fecundity = 5, ## more or less arbitrary
    K = 500
  )
```


Now we need to add all of this (plus information on the variables that stay constant, which output variables will we save...) to the experiment slot of the NL object (we encourage readers to look at the info pane in the .nlogo model file for details).

First let's just set a quick function to extract the right variable depending on the type of reproduction:

```{r variable-selector}
metrics_turtles <- function(repro){ 
  if(length(unique(repro)) > 1){stop("Error: please use only one type of reproduction by experiment. clonal OR sexual")}  
  
if(unique(repro)[1] == "clonal"){ 
  metrics.turtles <- list(
    "turtles" = c(
      "ind_fecundity",
      "genotype_logit_disp0", "noise_logit_disp0",
      "genotype_disp_slope", "noise_disp_slope",
      "x_birth", "disp",
      "momID", "PgrandmaID", "MgrandmaID",
      "pxcor", "who"
    ) # we save the pxcor of the turtle, rather than the xcor, because it makes patch-turtle joining easier downscript
  )
  }

if(unique(repro)[1] == "sexual"){ 
  metrics.turtles <- list(
    "turtles" = c(
      "ind_fecundity",
      "mean of genotype_logit_disp0", "noise_logit_disp0",
      "mean of genotype_disp_slope", "noise_disp_slope",
      "x_birth", "disp",
      "momID", "PgrandmaID", "MgrandmaID",
      "pxcor", "who"
    ) # we save the pxcor of the turtle, rather than the xcor, because it makes patch-turtle joining easier downscript
  )
  }

return(metrics.turtles)

}
```


```{r set-experiment}

nl_object@experiment <- experiment(
  expname = "experiment-h2-2020",
  outpath = here("NetLogo_output"),
  repetition = 1,
  tickmetrics = "true",
  idsetup = "setup",
  idgo = "go",
  stopcond = "not any? turtles",
  runtime = duration,
  evalticks = duration, # test run
  metrics = c("ticks", "present_front", "new_front"),
  metrics.patches = c("pxcor", "N_predispersal", "N_postdispersal", "N_allele0", "N_allele1"),
  metrics.turtles = metrics_turtles(trt_grid$reproduction),
  ## we need to add the individual metrics to save here
  constants = list(
    "duration" = duration
  ),
  variables = list( ### needs to be a nested list
    "disp0_mean" = list(values = trt_grid$disp0_mean),
    "slope_disp_mean" = list(values = trt_grid$slope_disp_mean),
    "heritability" = list(values = trt_grid$heritability),
    "variance_pheno_logit_disp0" = list(values = trt_grid$variance_pheno_logit_disp0),
    "variance_pheno_disp_slope" = list(values = trt_grid$variance_pheno_disp_slope),
    "fecundity" = list(values = trt_grid$fecundity),
    "K" = list(values = trt_grid$K),
    "reproduction" = list(values = trt_grid$reproduction_nl)
  )
)
```


And we're go for running the simulations! We set a "distinct" simulation design (see `nlrx` help).
(Careful, script is not parallelized, so running <!--the final version--> is expected to take up to a few hours)

```{r running-simulations}

# set.seed(1989) ## we can set a seed here to guarantee the seeds selected below are the same everytime
nl_object@simdesign <- simdesign_distinct(nl = nl_object, nseeds = nreplicates)
nl_object@simdesign@simseeds <- 1:nreplicates # or we can rewrite the nseeds here (to guarantee they are all different)
length(unique(nl_object@simdesign@simseeds)) == nreplicates # either way, check that all generated seeds are different
exp_h2 <- run_nl_all(nl_object)
```

# Output

We can now process the result for the main analyses. first we start by extracting (and renaming, for `sexual` scenarios) the variables we need:

```{r processing-output-presaving1}
tab <- exp_h2 %>%
  dplyr::select(ticks,
    slope_disp_mean, disp0_mean,
    variance_pheno_logit_disp0, variance_pheno_disp_slope,
    heritability,
    fecundity, K, reproduction,
    seedID = `random-seed`,
    metrics.patches, metrics.turtles,
    present_front, new_front
  )
```

Then we do some processing, to keep only the patches of interest, and to convert the table into a "one row = one individual" table:
```{r processing-output-presaving2}
tab <- tab %>%
  mutate(
    v_f = 2 * sqrt( ## v_f = expected velocity of "equivalent" pulled wave:
      log(fecundity) * (1 - 1 / K) * ## fecundity term at N = 1
        0.5 * invlogit(logit(disp0_mean) + (1 / K) * slope_disp_mean)
    ) ## dispersal term at N = 1
  ) %>%
  mutate(metrics.patches = map2(.x = metrics.patches, .y = present_front,
    .f = ~ .x %>%
      select(-c(agent, breed)) %>%  ## removing variables that could go in the way of correct patch-turtle joining
      filter(pxcor <= 1 | pxcor >= (.y - 1)) # we keep info from (the two) core patch(es) and (the two) edge patch(es)
      )) %>%
  mutate(metrics.turtles = map(metrics.turtles,
    .f = ~ .x %>%
      select(-c(agent, breed))
  )) %>%
  mutate(metrics.all = map2(metrics.patches, metrics.turtles,
    .f = ~ .x %>%
      inner_join(.y, by = "pxcor")
  )) %>%
  select(-c(metrics.turtles, metrics.patches)) %>%
  unnest(cols = c(metrics.all)) %>%
  mutate(replicateID = paste("slope", slope_disp_mean, "d0", disp0_mean, "VP", variance_pheno_disp_slope, "h2", heritability, reproduction, seedID, sep = "_")) %>%
  mutate(Location_full = paste(replicateID, pxcor, ticks))
```

We finish by some name standardisation, if the experiment involved sexual reproduction, and thus calls to the mean of allelic values during post-processing:
```{r name-standardisation}
if(unique(trt_grid$reproduction)=="sexual"){

tab <- tab %>% 
  rename(genotype_disp_slope=`mean of genotype_disp_slope`,genotype_logit_disp0=`mean of genotype_logit_disp0`)

}
```


```{r saving-output}
if(unique(trt_grid$reproduction)=="clonal"){
write_csv(tab, path = here("NetLogo_output","model-output-clonal.csv"))
}

if(unique(trt_grid$reproduction)=="sexual"){
write_csv(tab, path = here("NetLogo_output","model-output-sexual.csv"))
}

```

We can now use the `ibm-analysis` scripts to analyse the model outputs.
