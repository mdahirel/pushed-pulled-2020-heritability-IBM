---
title: 'supplementary'
author: "Maxime Dahirel & Chlo√© Guicharnaud"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(arm)
library(matrixStats)
library(tidyverse)
library(cowplot)
library(patchwork)
library(tidybayes)


library(cmdstanr)
library(brms)
options(mc.cores = 4)

library(tidyverse)

library(here)
```



```{r}
raw_data <- read_csv(here("NetLogo_output","simulation_output.csv"))
```

We rewrite variance variables to be in 0/1 mode to not be distracted

```{r}
data<- raw_data  %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0))
```

what width do we use to define a "front" for sampling purposes?


```{r}
##supplementary plot to justify arbitrary front size =5 ish

data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_predispersal>0))) %>% ###works with pre or post
  filter(pxcor>front-20 & pxcor<=front) %>% ### do same plot with core
  ggplot()+
  stat_pointinterval(aes(front-pxcor,N_predispersal),
                     .width=c(0.01,0.95))+ ##works with pre or post
  scale_x_continuous("distance to edge")+
  scale_y_continuous("pre-dispersal population size")+
  geom_vline(xintercept = c(4.5),col="red")+
 facet_grid(rows=vars(paste("m =",dispersal_mortality)),
               cols=vars(paste("h2=",heritability),paste("fec=",fecundity)))
```



# note on hwy relying on alpha rather than beta to produce flat functions is a bad idea

```{r}
library(arm)

K=250
x=c(0:K)

plot(x,invlogit(3*(x-0.01))) ##generates indeed the flat function
abline(h=0.95)

 plot(x,invlogit(K*3*(x/K-0.01/K))) ##same expressed in N/K

## a normal(0,1.5*K) distribution of initial slope would be able to pull those not too frequently but enough to be selected
 slope_distri=rnorm(10000,0,1.5*K)
hist(slope_distri)
abline(v=c(-3*K,3*K))


## would it lead to appropriately balanced distribution of starting function shapes?
# we used the fact that teh typical time to go from 5% to 95% is 6/abs(alpha)

quantile(6/(abs(slope_distri)),0.95)
## almost all the starting strategies would be narrow (take less than 0.25K to)
```




# checking evolutionary and velocity convergence


```{r}
tab_dynamics<-data %>% 
  filter(ticks>1) %>% 
  group_by(replicateID,ticks,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,fecundity) %>% 
  summarise(front=max(pxcor*(N_postdispersal>0))) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(persist=max(ticks)) %>% 
  ungroup() %>% 
  filter(persist==120) %>% # to evaluate long-run speed we need to keep only exp that were long run
  ## a problem for fec=1.5 only
  group_by(replicateID) %>% 
  arrange(ticks) %>% 
  mutate(prev_front=lag(front)) %>% 
  mutate(prev_front=replace_na(prev_front,0)) %>% 
  mutate(speed_segment=(front-prev_front)/20) %>% 
  mutate(overall_speed=subset(front,ticks==120)/120) %>% 
  ungroup()

  ggplot(tab_dynamics)+
    geom_hline(yintercept=0,lty=2)+
  geom_boxplot(aes(factor(ticks),speed_segment-overall_speed))+
  #facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
  #             cols=vars(heritability,is.VP_DDD))+
  scale_y_continuous("deviation from overall velocity (in patches per generation)")+
  scale_x_discrete("time interval (generations)",
                   labels=c("0-20","20-40","40-60","60-80","80-100","100-120"))+
  theme(legend.position = "none")+
    facet_wrap(~fecundity)

## add test to see if noise deviate from binomial expectation?  
  
expected=tibble(x=c(1:99)/100) %>% 
  mutate(y=map(.x=x,.f=function(.x){return(rbinom(n=1000,size=20,prob=.x)/20)})) %>% 
  unnest(cols=y)

tab_dynamics %>% 
  mutate(ticks2=fct_recode(factor(ticks),
                           `0-20`="20",
                           `20-40`="40",
                           `40-60`="60",
                           `60-80`="80",
                           `80-100`="100",
                           `100-120`="120")) %>% 
ggplot()+
  stat_lineribbon(data=expected,aes(x,y),.width=c(0.001,0.95),col=NA,alpha=0.5)+
  geom_point(aes(overall_speed,speed_segment),alpha=0.3)+
  geom_abline(intercept=0,slope=1)+
  scale_x_continuous("overall expansion velocity from t=0 to t=120 (patches/generation)")+
  scale_y_continuous("expansion velocity over a 20 generations interval (patches/generation)")+
  theme(legend.position = "none")+
    facet_grid(cols=vars(ticks2),rows=vars(paste("r0 = log(",fecundity,")")))  
  

mod=lm(speed_segment~0+interaction(ticks,fecundity)+overall_speed:interaction(ticks,fecundity),data=tab_dynamics)
summary(mod)
```




takeaway: convergence in speed (which depends on both the stochasticity of the invasion smoothing itself out and the evolutionary process finishing) is fast, and speeds at g100 or g120 can reasonably be used as measures of long-run speed

let's do the same to look at evolutionary stability at the edge


(we can NOT use "check if vA falls to zero" as a check for evolutionary stability, because in case of branching within a replicate, dynamics can be stable but vA very high, even higher than at t0 if "core" of the genotypic distri has been carved out)
(well we can, but we have to caveat it)

lots of things to do to strengthen this, but we can carry on assuming convergence at g100 for the enxt steps

```{r}
test= data %>% 
  filter(heritability>0) %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor>front-5) %>%  
  group_by(replicateID,ticks,heritability,is.VP_dmax,is.VP_DDD,dispersal_mortality,
           VP_logit_dmax,VP_slope,VP_midpoint,fecundity) %>%
  mutate(var_genotype_logit_dmax=replace_na(var_genotype_logit_dmax,0),
         var_genotype_midpoint=replace_na(var_genotype_midpoint,0),
         var_genotype_slope=replace_na(var_genotype_slope,0)) %>% 
  summarise(var_genotype_logit_dmax=weighted.mean(var_genotype_logit_dmax,N_predispersal,na.rm=TRUE),
            var_genotype_midpoint=weighted.mean(var_genotype_midpoint,N_predispersal,na.rm=TRUE),
            var_genotype_slope=weighted.mean(var_genotype_slope,N_predispersal,na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(
    is.fixed_dmax=var_genotype_logit_dmax<(0.05*VP_logit_dmax),
    is.fixed_slope=var_genotype_slope<(0.05*VP_slope),
    is.fixed_midpoint=var_genotype_midpoint<(0.05*VP_midpoint)
  ) 

test %>% 
  filter(is.VP_dmax>0) %>% 
  group_by(ticks,fecundity) %>% 
  summarise(prop_dmax=mean(is.fixed_dmax)) %>% 
  ggplot()+
  geom_line(aes(ticks,prop_dmax))+
  #geom_hline(yintercept=0.9,lty=2)+
  scale_y_continuous("proportion of replicates with <5% of initial genetic variation remaining at the edge")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")+
  facet_wrap(~paste("fecundity=",fecundity))


test %>% 
  filter(is.VP_DDD>0) %>% 
  group_by(ticks,fecundity) %>% 
  summarise(prop_slope=mean(is.fixed_slope),
            prop_midpoint=mean(is.fixed_midpoint)) %>% 
  ggplot()+
  geom_line(aes(ticks,prop_midpoint))+
  #geom_hline(yintercept=0.9,lty=2)+
  scale_y_continuous("proportion of replicates with <5% of initial genetic variation remaining at the edge")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")+
  facet_wrap(~paste("fecundity=",fecundity))
```


## comparing core and edge

# making sub data tables

a table with summary variables at the edge (we define edge as patch <5 patchs from tip, see suppl for justification)
```{r}
tab_edge<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor > front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    mean_varslope=weighted.mean(var_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_vard0=weighted.mean(var_d0,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,
                            mean_varslope,mean_vard0,
                            front)) %>% 
  mutate(where="edge")
```

we do the same for core patches

```{r}
tab_core<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor < 5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    mean_varslope=weighted.mean(var_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_vard0=weighted.mean(var_d0,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,
                            mean_varslope,mean_vard0,
                            front)) %>% 
  mutate(where="core")
```
