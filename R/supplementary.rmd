---
title: 'Supplementary Material for "Individual variation in dispersal, and its sources, shape the fate of pushed vs. pulled range expansions"'
author: "Maxime Dahirel, Chlo√© Guicharnaud, Elodie Vercken"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(arm)
library(matrixStats)
library(tidyverse)
library(cowplot)
library(patchwork)
library(ggdist)

library(tidyverse)

library(here)
```

# S1 - Effect of the magnitude of initial variation in $\alpha$ on density dependence

In the main text, we discuss how allowing for negative $\beta$ is the only way we have to allow for mostly flat dispersal-density function where dispersal is close to $d_{max}$. We briefly explain that one seeming alternative, allowing very large $|\alpha|$ values so that dispersal goes from 0 to $d_{max}$ in less than 1 individual, is not viable. We expand this argument here:

- first, using $\alpha$ in this way would mean that $d_{0}$ becomes, in a way, a by-product of adjusting the shape of the curve, rather than its own trait of interest. This is not a good option when studying pushed vs. pulled expansions;

- second, we'd need the initial trait distribution to contain both these very large $\alpha$ (positive and negative) *and* $\alpha$ close to 0, for evolution to be possible. It's easy to demonstrate that distributions that fulfill this requirement are actually biased towards very sharp density-dispersal functions. If we assume $K = 250$ as in our simulations, and population densities are expressed as $N/K$, then $\alpha = 300$ (with $\beta$ very close to 0) is high enough to generate one of these nearly flat functions:

```{r}
tab<- expand_grid(
  K=250,
  x=0:50)

ggplot(tab)+
  geom_line(aes(x,0.5/(1+exp(-1000*(x/K-0.000000000000001)))))+
  scale_x_continuous("Population density")+
  scale_y_continuous("Dispersal rate")+
  geom_vline(xintercept = 1, lty=2)+
  geom_hline(yintercept = 0.95*0.5, lty=2)+
  theme_bw()
```

So, even after setting $\beta$ absurdly close to 0, we still need $\alpha$ in the neigbourhood of 1000 (i.e. $4K$) to be able to produce such shapes. An initial distribution of $\alpha$ of $\mathrm{Normal}(0,500)$ would hit these extremes with a low but non-negligible probability (about 5%). And we've established (see main text) that $6/\alpha$ expresses (in units of $K$) how sharp the increase in dispersal with density is. Let's have a look at the distribution of $6/|\alpha|$ implied by $\alpha \sim \mathrm{Normal}(0,1.5)$ :

```{r}
set.seed(42)
tibble(x=rnorm(10000,0,500)) %>% 
  ggplot()+
  geom_histogram(aes(6/abs(x)),binwidth = 0.1)+
  geom_vline(xintercept = 1, lty=2)+
  coord_cartesian(xlim=c(0,5))+
  scale_x_continuous("increase in density needed to go from 5% dmax to 95% dmax (or vice-versa)(expressed in units of K)")+
  theme_bw()
```

It's easy to see that this initial distribution of $\alpha$ would almost only allow sharp slopes, that take less than 20-50%$K$ to reach $d_{max}$, and disallow shallower slopes. This is not a choice that is sound in our opinion, hence why we rejected "extreme $\alpha$" as a method to generate $d_{N} \simeq d_{max}$ functions.

# S2 - How do we define the "range front"?

```{r load data}
### let's start by loading the data
raw_data <- read_csv(here("NetLogo_output","simulation_output.csv"))

#We rewrite variance variables to be in 0/1 mode to not be distracted

data<- raw_data  %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0))
```

We are interested in how traits at the front of the expansion are shaped by, and shape, the expansion process. To do that right, we need an operational definition of what is the front/edge. A "traditional" one is the range of patches where a density gradient is seen, i.e. where population density has not yet reached its equilibrium. Let's have a look: 

```{r}
##supplementary plot to justify arbitrary front size =5 ish

data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(edge=max(pxcor*(N_predispersal>0))) %>% ###works with pre or post
  filter(pxcor>edge-20 & pxcor<=edge) %>%
  ggplot()+
  geom_boxplot(aes(edge-pxcor,N_predispersal,group=edge-pxcor))+ ##works with pre or post
  scale_x_continuous("distance to edge")+
  scale_y_continuous("pre-dispersal population size")+
  geom_vline(xintercept = c(4.5),col="red")+
 facet_grid(rows=vars(paste("m =",dispersal_mortality)),
               cols=vars(paste("h2=",heritability),paste("fec=",fecundity)))+
  theme_bw()
```


We can see that a threshold where we consider all patches < 5 patches from the edge as belonging to the range front is a good compromise that works across conditions (Narrower fronts would probably work for fecundity = 5, but would not work for fecundity = 1.5 and in addition would limit the number of individuals included, reducing precision of our trait means; wider fronts would lead us to fronts that are dominated by what are clearly non-front patches when fecundity =5)

# S3 - Checking velocity and evolutionary convergence

## velocity convergence

If an expansion has converged to its asymptotic speed after a time $t$, then it means that its speed over the full duration of the simulation (if >$t$) and its speed over any interval after $t$ should be identical (to noise, of course). We sampled our simulations every 20 generations; it is relatively easy to test for convergence then by regressing expansion speeds over each of these 20 generations periods on the corresponding overall speed:


```{r}
tab_dynamics<-data %>% 
  filter(ticks>1) %>% 
  group_by(replicateID,ticks,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,fecundity) %>% 
  summarise(edge=max(pxcor*(N_postdispersal>0))) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(persist=max(ticks)) %>% 
  ungroup() %>% 
  filter(persist==120) %>% # to be able to evaluate long-run speed we need to keep only these that persisted
  ## remove a few expansions for fecundity =1.5 only
  group_by(replicateID) %>% 
  arrange(ticks) %>% 
  mutate(prev_front=lag(front)) %>% 
  mutate(prev_front=replace_na(prev_front,0)) %>% 
  mutate(speed_segment=(front-prev_front)/20) %>% 
  mutate(overall_speed=subset(front,ticks==120)/120) %>% 
  ungroup()
```


```{r}
ggplot(tab_dynamics)+
    geom_hline(yintercept=0,lty=2)+
  geom_boxplot(aes(factor(ticks),speed_segment/overall_speed))+
  #facet_grid(rows=vars(dispersal_mortality,is.VP_dmax),
  #             cols=vars(heritability,is.VP_DDD))+
  scale_y_continuous("deviation from overall velocity (in patches per generation)")+
  scale_x_discrete("time interval (generations)",
                   labels=c("0-20","20-40","40-60","60-80","80-100","100-120"))+
  theme(legend.position = "none")+
    facet_wrap(~fecundity)
```


```{r}
## add test to see if noise deviate from binomial expectation?  
  
expected=tibble(x=c(1:99)/100) %>% 
  mutate(y=map(.x=x,.f=function(.x){return(rbinom(n=1000,size=20,prob=.x)/20)})) %>% 
  unnest(cols=y)

tab_dynamics %>% 
  mutate(ticks2=fct_recode(factor(ticks),
                           `0-20`="20",
                           `20-40`="40",
                           `40-60`="60",
                           `60-80`="80",
                           `80-100`="100",
                           `100-120`="120")) %>% 
ggplot()+
  stat_lineribbon(data=expected,aes(x,y),.width=c(0.001,0.95),col=NA,alpha=0.5)+
  geom_point(aes(overall_speed,speed_segment),alpha=0.3)+
  geom_abline(intercept=0,slope=1)+
  scale_x_continuous("overall expansion velocity from t=0 to t=120 (patches/generation)")+
  scale_y_continuous("expansion velocity over a 20 generations interval (patches/generation)")+
  theme(legend.position = "none")+
    facet_grid(cols=vars(ticks2),rows=vars(paste("r0 = log(",fecundity,")")))
```

takeaway: convergence in speed (which depends on both the stochasticity of the invasion smoothing itself out and the evolutionary process finishing) is fast, and speeds at g100 or g120 can reasonably be used as measures of long-run speed

## evolutionary convergence

let's do the same to look at evolutionary stability at the edge


(we can NOT use "check if vA falls to zero" as a check for evolutionary stability, because in case of branching within a replicate, dynamics can be stable but vA very high, even higher than at t0 if "core" of the genotypic distri has been carved out)
(well we can, but we have to caveat it)

lots of things to do to strengthen this, but we can carry on assuming convergence at g100 for the enxt steps

```{r}
test= data %>% 
  filter(heritability>0) %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor>front-5) %>%  
  group_by(replicateID,ticks,heritability,is.VP_dmax,is.VP_DDD,dispersal_mortality,
           VP_logit_dmax,VP_slope,VP_midpoint,fecundity) %>%
  mutate(var_genotype_logit_dmax=replace_na(var_genotype_logit_dmax,0),
         var_genotype_midpoint=replace_na(var_genotype_midpoint,0),
         var_genotype_slope=replace_na(var_genotype_slope,0)) %>% 
  summarise(var_genotype_logit_dmax=weighted.mean(var_genotype_logit_dmax,N_predispersal,na.rm=TRUE),
            var_genotype_midpoint=weighted.mean(var_genotype_midpoint,N_predispersal,na.rm=TRUE),
            var_genotype_slope=weighted.mean(var_genotype_slope,N_predispersal,na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(
    is.fixed_dmax=var_genotype_logit_dmax<(0.05*VP_logit_dmax),
    is.fixed_slope=var_genotype_slope<(0.05*VP_slope),
    is.fixed_midpoint=var_genotype_midpoint<(0.05*VP_midpoint)
  ) 

test %>% 
  filter(is.VP_dmax>0) %>% 
  group_by(ticks,fecundity) %>% 
  summarise(prop_dmax=mean(is.fixed_dmax)) %>% 
  ggplot()+
  geom_line(aes(ticks,prop_dmax))+
  #geom_hline(yintercept=0.9,lty=2)+
  scale_y_continuous("proportion of replicates with <5% of initial genetic variation remaining at the edge")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")+
  facet_wrap(~paste("fecundity=",fecundity))


test %>% 
  filter(is.VP_DDD>0) %>% 
  group_by(ticks,fecundity) %>% 
  summarise(prop_slope=mean(is.fixed_slope),
            prop_midpoint=mean(is.fixed_midpoint)) %>% 
  ggplot()+
  geom_line(aes(ticks,prop_midpoint))+
  #geom_hline(yintercept=0.9,lty=2)+
  scale_y_continuous("proportion of replicates with <5% of initial genetic variation remaining at the edge")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")+
  facet_wrap(~paste("fecundity=",fecundity))
```


## comparing core and edge

# making sub data tables

a table with summary variables at the edge (we define edge as patch <5 patchs from tip, see suppl for justification)
```{r}
tab_edge<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor > front-5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    mean_varslope=weighted.mean(var_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_vard0=weighted.mean(var_d0,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,
                            mean_varslope,mean_vard0,
                            front)) %>% 
  mutate(where="edge")
```

we do the same for core patches

```{r}
tab_core<-data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(front=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor < 5 ) %>%
  ungroup() %>% 
  group_by(replicateID,ticks,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD) %>% 
  summarise(
    min_N=min(N_predispersal,na.rm=TRUE),
    max_N=max(N_predispersal,na.rm=TRUE),
    mean_dmax=weighted.mean(mean_dmax,N_predispersal,na.rm=TRUE),
    mean_slope=weighted.mean(mean_slope,N_predispersal,na.rm=TRUE),
    mean_midpoint=weighted.mean(mean_midpoint,N_predispersal,na.rm=TRUE),
    mean_d0=weighted.mean(mean_d0,N_predispersal,na.rm=TRUE),
    mean_avgslope=weighted.mean(mean_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_Kslope=weighted.mean(mean_slopeA_0_K,N_predispersal,na.rm=TRUE),
    mean_uncond=weighted.mean(mean_uncond_0_K,N_predispersal,na.rm=TRUE),
    mean_varslope=weighted.mean(var_slopeA_0_avg,N_predispersal,na.rm=TRUE),
    mean_vard0=weighted.mean(var_d0,N_predispersal,na.rm=TRUE),
    front=mean(front)
  ) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(range_N=max(max_N)-min(min_N)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(replicateID,dispersal_mortality,heritability,is.VP_dmax,is.VP_DDD,
                          range_N),
              names_from=ticks,
              values_from=c(mean_dmax,mean_slope,mean_midpoint,
                            mean_d0,mean_avgslope,mean_Kslope,mean_uncond,
                            mean_varslope,mean_vard0,
                            front)) %>% 
  mutate(where="core")
```
