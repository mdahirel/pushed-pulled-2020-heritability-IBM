---
title: 'Supplementary Material for "Individual variation in dispersal, and its sources, shape the fate of pushed vs. pulled range expansions"'
author: "Maxime Dahirel, Chlo√© Guicharnaud, Elodie Vercken"
date:
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

```{r load-packages}
library(arm)         # CRAN v1.11-2
library(matrixStats) # CRAN v0.60.0
library(tidyverse)   # CRAN v1.3.1 # CRAN v1.3.1
library(cowplot)     # [github::wilkelab/cowplot] v1.1.1
library(patchwork)   # CRAN v1.1.1
library(ggdist)      # CRAN v3.0.0

library(tidyverse)   # CRAN v1.3.1 # CRAN v1.3.1

library(here)        # CRAN v1.0.1
```

# S1 - Effect of the magnitude of initial variation in $\alpha$ on density dependence

In the main text, we discuss how allowing for negative $\beta$ is the only way we have to allow for mostly flat dispersal-density function where dispersal is close to $d_{max}$. We briefly explain that one seeming alternative, allowing very large $|\alpha|$ values so that dispersal goes from 0 to $d_{max}$ in less than 1 individual, is not viable. We expand this argument here:

- first, using $\alpha$ in this way would mean that $d_{0}$ becomes, in a way, a by-product of adjusting the shape of the curve, rather than its own trait of interest. This is not a good option when studying pushed vs. pulled expansions;

- second, we'd need the initial trait distribution to contain both these very large $\alpha$ (positive and negative) *and* $\alpha$ close to 0, for evolution to be possible. It's easy to demonstrate that distributions that fulfill this requirement are actually biased towards very sharp density-dispersal functions. If we assume $K = 250$ as in our simulations, and population densities are expressed as $N/K$, then $\alpha = 300$ (with $\beta$ very close to 0) is high enough to generate one of these nearly flat functions:

```{r}
tab<- expand_grid(
  K=250,
  x=0:50)

ggplot(tab)+
  geom_line(aes(x,0.5/(1+exp(-1000*(x/K-0.000000000000001)))))+
  scale_x_continuous("Population density")+
  scale_y_continuous("Dispersal rate")+
  geom_vline(xintercept = 1, lty=2)+
  geom_hline(yintercept = 0.95*0.5, lty=2)+
  theme_bw()
```

So, even after setting $\beta$ absurdly close to 0, we still need $\alpha$ in the neigbourhood of 1000 (i.e. $4K$) to be able to produce such shapes. An initial distribution of $\alpha$ of $\mathrm{Normal}(0,500)$ would hit these extremes with a low but non-negligible probability (about 5%). And we've established (see main text) that $6/\alpha$ expresses (in units of $K$) how sharp the increase in dispersal with density is. Let's have a look at the distribution of $6/|\alpha|$ implied by $\alpha \sim \mathrm{Normal}(0,1.5)$ :

```{r}
set.seed(42)
tibble(x=rnorm(10000,0,500)) %>% 
  ggplot()+
  geom_histogram(aes(6/abs(x)),binwidth = 0.1)+
  geom_vline(xintercept = 1, lty=2)+
  coord_cartesian(xlim=c(0,5))+
  scale_x_continuous("increase in density needed to go from 5% dmax to 95% dmax (or vice-versa)(expressed in units of K)")+
  theme_bw()
```

It's easy to see that this initial distribution of $\alpha$ would almost only allow sharp slopes, that take less than 20-50%$K$ to reach $d_{max}$, and disallow shallower slopes. This is not a choice that is sound in our opinion, hence why we rejected "extreme $\alpha$" as a method to generate $d_{N} \simeq d_{max}$ functions.

# S2 - How do we define the "range front"?

```{r load data}
### let's start by loading the data
raw_data <- read_csv(here("NetLogo_output","simulation_output.csv"))

#We rewrite variance variables to be in 0/1 mode to not be distracted

data<- raw_data  %>% 
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0))
```

We are interested in how traits at the front of the expansion are shaped by, and shape, the expansion process. To do that right, we need an operational definition of what is the front/edge. A "traditional" one is the range of patches where a density gradient is seen, i.e. where population density has not yet reached its equilibrium. Let's have a look: 

```{r}
##supplementary plot to justify arbitrary front size =5 ish

data %>% 
  group_by(replicateID,ticks) %>% 
  mutate(edge=max(pxcor*(N_predispersal>0))) %>% ###works with pre or post
  filter(pxcor>edge-20 & pxcor<=edge) %>%
  ggplot()+
  geom_boxplot(aes(edge-pxcor,N_predispersal,group=edge-pxcor))+ ##works with pre or post
  scale_x_continuous("distance to edge")+
  scale_y_continuous("pre-dispersal population size")+
  geom_vline(xintercept = c(4.5),col="red")+
 facet_grid(rows=vars(paste("m =",dispersal_mortality)),
               cols=vars(paste("h2=",heritability),paste("fec=",fecundity)))+
  theme_bw()
```


We can see that a threshold where we consider all patches < 5 patches from the edge as belonging to the range front is a good compromise that works across conditions (Narrower fronts would probably work for fecundity = 5, but would not work for fecundity = 1.5 and in addition would limit the number of individuals included, reducing precision of our trait means; wider fronts would lead us to fronts that are dominated by what are clearly non-front patches when fecundity =5)

# S3 - Checking velocity and evolutionary convergence

## velocity convergence

If an expansion has converged to its asymptotic speed after a time $t$, then it means that its speed over the full duration of the simulation (if >$t$) and its speed over any interval after $t$ should be identical (to noise, of course).

```{r}
speed_convergence <-data %>% 
  filter(ticks>1) %>% 
  group_by(replicateID,ticks,dispersal_mortality,is.VP_dmax,is.VP_DDD,heritability,fecundity) %>% 
  summarise(edge=max(pxcor*(N_postdispersal>0))) %>% 
  ungroup() %>% 
  group_by(replicateID) %>% 
  mutate(persist=max(ticks)) %>% 
  ungroup() %>% 
  filter(persist==120) %>% # to be able to evaluate long-run speed we need to keep only these that persisted
  ## remove a few expansions for fecundity =1.5 only
  group_by(replicateID) %>% 
  arrange(ticks) %>% 
  mutate(prev_front=lag(front)) %>% 
  mutate(prev_front=replace_na(prev_front,0)) %>% 
  mutate(speed_segment=(front-prev_front)/20) %>% 
  mutate(overall_speed=subset(front,ticks==120)/120) %>% 
  ungroup()
```


```{r}
speed_convergence %>% 
  filter(overall_speed>0) %>% #can't divide by overall speed if it is 0
  ggplot()+
    geom_hline(yintercept=1,lty=2)+
  geom_boxplot(aes(factor(ticks),speed_segment/overall_speed))+
  scale_y_continuous("ratio between velocity over interval and overall velocity")+
  scale_x_discrete("time interval (generations)",
                   labels=c("0-20","20-40","40-60","60-80","80-100","100-120"))+
  theme(legend.position = "none")+
    facet_grid(rows=vars(paste("r0 = log(",fecundity,")")))+
  coord_cartesian(ylim=c(0,5))
##we cut outliers <0 (negative speeds over intervals) and >5 for clarity
```

We find that convergence in expansion velocities is fast, and speeds measured at or after 100 generations can reasonably used as measures of long-run speed.

## evolutionary convergence

We can then do a similar check for evolutionary stability at the edge. Because there is always some genetic variation remaining, let's use "only 5% of the initial genetic variation in traits remaining at the front" as an arbitrary cutoff:

```{r}
evo_convergence <- data %>% 
  filter(heritability>0) %>% # doesn't make sens to test non-evolving replicates
  mutate(is.VP_dmax=as.numeric(VP_logit_dmax >0),
           is.VP_DDD=as.numeric(VP_slope >0)) %>% 
  group_by(replicateID,ticks) %>% 
  mutate(edge=max(pxcor*(N_postdispersal>0))) %>% 
  filter(pxcor>edge-5) %>%  
  group_by(replicateID,ticks,heritability,is.VP_dmax,is.VP_DDD,dispersal_mortality,
           VP_logit_dmax,VP_slope,VP_midpoint,fecundity) %>%
  summarise(var_genotype_logit_dmax=weighted.mean(var_genotype_logit_dmax,N_predispersal,na.rm=TRUE),
            var_genotype_midpoint=weighted.mean(var_genotype_midpoint,N_predispersal,na.rm=TRUE),
            var_genotype_slope=weighted.mean(var_genotype_slope,N_predispersal,na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(
    is.fixed_dmax=var_genotype_logit_dmax<(0.05*VP_logit_dmax),
    is.fixed_slope=var_genotype_slope<(0.05*VP_slope),
    is.fixed_midpoint=var_genotype_midpoint<(0.05*VP_midpoint)
  ) 

dmax_convergence <- evo_convergence %>% 
  filter(is.VP_dmax>0) %>% ## doesn't make sense to test it in replicates with no variation at the start
  group_by(ticks,fecundity) %>% 
  summarise(prop_dmax=mean(is.fixed_dmax))

ddd_convergence <- evo_convergence %>% 
  filter(is.VP_DDD>0) %>% 
  group_by(ticks,fecundity) %>% 
  summarise(prop_slope=mean(is.fixed_slope),
            prop_midpoint=mean(is.fixed_midpoint)) 

ggplot()+
  geom_line(data=ddd_convergence,aes(ticks,prop_midpoint),col="red")+
  geom_line(data=ddd_convergence,aes(ticks,prop_slope),col="green")+
  geom_line(data=dmax_convergence,aes(ticks,prop_dmax),col="blue")+
  geom_hline(yintercept=0.9,lty=2)+
  scale_y_continuous("proportion of replicates with <5% of initial genetic variation remaining at the edge")+
  scale_x_continuous("generations")+
  theme(legend.position = "none")+
  facet_wrap(~paste("fecundity=",fecundity))
```

Using our operational definition of evolutionary "stability", we note that a very large majority of replicates have converged by the end of the experiment, especially in high fecundity replicates. In addition, we note that our definition of evolutionary stability excludes cases of divergent selection, so the % of "evolutionary stable" expansions by $t$=100 generations, say, is likely even higher.

# S4 - results but for fecundity = 1.5


```{r}
tab<-tab_all %>% 
  filter(fecundity==1.5)
```

!!WAIT UNTIL THE EQUIVALENT CODE FOR MAIN ANALYSIS IS CLEAN AND THEN COPY IT
(iwth adjustments re: which is best model for 4.2 and 4.3)

S4.1 model selection

S4.2 effect on speed

S4.3 effect on gen div

S4.4 evol of dmax

S4.5 evol of DDD


# S5 - an unconditionality metric

A key prediction from <!--ref--> is that dispersal becomes more and more density-independent at range edges. That is, the dispersal-density function becomes flat over a larger and larger range of densities. We find (see main text) that density-dependence relevant to pushed vs pulled expansions still exists after evolution at the range edge. How to reconcile this?

It is relatively easy actually: the first step is to see that "flat over a larger and larger range of densities" does not mean "uniformly flat". As long as dispersal is slightly lower at specifically low densities, pushed dynamics can still happen, even if dispersal is fully independent of density over the rest of possible densities. The second step is to define an actual unconditionality index, and to test the prediction that, despite our results, expansions still tend to become unconditional, on average. 

For a given emigration-density function $f(n)$ and a relevant range of densities $[0-K]$, we can define an unconditionality index $u$ as follows:

$u = \frac{\int_{0}^{K}f(n)\mathrm{d}n}{\max\limits_{0 \leq n \leq K} f(n)}$.

This index can take values between 0 and 1. The closer this index is to 1, the closer the average dispersal rate over the range 0-$K$ is equal to the maximal dispersal rate over the same range, i.e. the closer the dispersal function is to an horizontal line. For simplicity, as integrating within NetLogo is non-trivial, we approximated the numerator of $u$ by instead sampling $l$ density values at regular intervals over the range of densities and averaging the resulting dispersal rates:

$N = \{0, 0.1K, 0.2K,...,0.9K,K\}$,

$u_{[approx]} = \frac{(\sum_{n \in N}f(n))/l}{\max\limits_{n \in N} f(n)}$.

We can then easily see that evolution indeed leads dispersal to become more unconditional when fecundity is high (<!--FIG-->). When fecundity is reduced, dispersal still becomes more unconditional with expansion, unless mortality costs are high (<!--fig-->). Jointly with our main text result, this confirms that metrics specifically targeting differences to low-density behaviour are needed to understand pushed expansions.

```{r}
tab<-tab_all %>% 
  filter(fecundity==1.5)
```

```{r}
p11<- tab %>% 
  filter(is.VP_dmax==1 & is.VP_DDD==1) %>% 
  ggplot()+
    geom_point(aes(start_uncond,
                   mean_uncond_100-start_uncond),
               col="grey80")+
    geom_smooth(aes(start_uncond,
                    mean_uncond_100-start_uncond),
                method="lm",
                col="black",fill="red")+
  labs(title='C: Individual variation in *&alpha;*, *&beta;*, and *d<sub>max</sub>*')+
  scale_y_continuous("")+
  scale_x_continuous("")

p10<- tab %>% 
  filter(is.VP_dmax==1 & is.VP_DDD==0) %>% 
  ggplot()+
    geom_point(aes(start_uncond,
                   mean_uncond_100-start_uncond),
               col="grey80")+
    geom_smooth(aes(start_uncond,
                    mean_uncond_100-start_uncond),
                method="lm",
                col="black",fill="red")+
 labs(title='B: Individual variation in *d<sub>max</sub>*')+
  scale_x_continuous("Dispersal unconditionality index at *t* = 0")+
  scale_y_continuous("")
#the white area delimitate the maximal space available for evolution (slope or davg after avolution cannot go higher than abs(maximal dmax possible under the variance conditions))
#note that no var vignettes should probably be all grey (no evolution possible)

p01<- tab %>% 
  filter(is.VP_dmax==0 & is.VP_DDD==1) %>% 
  ggplot()+
    geom_point(aes(start_uncond,
                   mean_uncond_100-start_uncond),
               col="grey80")+
    geom_smooth(aes(start_uncond,
                    mean_uncond_100-start_uncond),
                method="lm",
                col="black",fill="red")+
  scale_y_continuous("Change in unconditionality index at the edge between *t* = 0 et *t* = 100")+
  scale_x_continuous("")+
  ggtitle("A: Individual variation in *&alpha;* and *&beta;*")

(p01+p10+p11) &
  coord_cartesian(ylim=c(-1,1),
                  xlim=c(0,1))&
  geom_hline(yintercept = 0,lty=2) &
  facet_grid(rows=vars(paste("*m* =",dispersal_mortality)),
               cols=vars(paste("*h^2* =",heritability))) &
  theme_bw()&
  theme(strip.text.x=element_markdown(),
        strip.text.y=element_markdown(),
        axis.title.x = element_markdown(),
        axis.title.y=element_markdown(),
        plot.title=element_markdown())

```


